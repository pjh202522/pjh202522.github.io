{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"友♂情","date":"2013-07-13T12:46:25.000Z","updated":"2022-01-02T09:18:29.157Z","comments":true,"path":"PY.html","permalink":"http://example.com/PY.html","excerpt":"","text":""},{"title":"文章归档","date":"2022-01-02T09:59:13.683Z","updated":"2022-01-02T09:59:13.683Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Vue","date":"2022-01-02T09:58:01.249Z","updated":"2021-12-12T03:57:15.298Z","comments":true,"path":"2022/01/02/Vue/","link":"","permalink":"http://example.com/2022/01/02/Vue/","excerpt":"","text":"1 前端知识体系1.1 前端三件套 HTML（结构）：超文本标记型语言，决定网页的结构和内容。 CSS（表现）：层叠样式表，设定页面的表现样式。 JavaScript（行为）：弱类型交互式脚本语言，控制网页的行为。 1.1.1 结构层HTML略 1.1.2 表现层CSSCSS是一门标记型语言，他不能用于编程，所以无法自定义变量，不可以引用，有如下缺点： 语法不够强大，无法嵌套书写，导致模块化开发中需要重复写很多选择器。 没有变量和合理的样式复用机制，使得逻辑上的属性值必须以字面量的形式重复输出，导致难以维护。 为了解决这些拖累开发的问题，前端程序员会使用一种称为CSS预处理器的工具。 CSS预处理器： CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来说就是**”用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用”**。 常用的CSS预处理器： SASS：基于Ruby，通过服务端处理，功能强大。解析效率高。需要学习Ruby语言，上手难度高于LESS。 LESS：基于NodeJS，通过客户端处理，使用简单。功能比SASS简单，解析效率也低于SASS，但在实际开发中足够了，所以我们后台人员如果需要的话，建议使用LESS。 1.1.3 行为层JavaScriptJavaScript一门弱类型脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。 Native 原生JS开发： 原生JS开发，也就是让我们按照【ECMAScript】标准的开发方式，简称是ES，特点是所有浏览器都支持。截止到目前，ES标准已发布如下版本： ES3 ES4（内部，未正式发布） ES5（全浏览器支持） ES6（常用，当前主流版本） ES7 ES8 ES9（草案阶段） 区别就是逐步增加新特性。 TypeScript微软的标准： TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯·海尔斯伯格（C#、Delphi、TypeScript之父；。NET创立者）主导。 该语言的特点就是除了具备ES的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持TypeScript语法，需要编译后（编译成JS）才能被浏览器正确执行。 JavaScript框架： jQuery：大家熟知的JavaScript 框架，优点是简化了DOM操作，缺点是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6、7、8； Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如：1代-&gt;2代，除了名字，基本就是两个东西）； React：Facebook出品，一款高性能的JS前端框架;特点是提出了新概念【虚拟DOM】用于减少真实DOM操作，在内存中模拟DOM操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门【JSX】语言; vue：一款渐进式JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了Angular(模块化)和React(虚拟DOM）的优点； Axios：前端通信框架；因为vue的边界很明确，就是为了处理DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能； UI框架： Ant-Design：阿里巴巴出品，基于React的UI框架 ElementUl：饿了么出品，基于Vue的UI框架 Bootstrap: Twitter推出的一个用于前端开发的开源工具包 AmazeUI：又叫”妹子UI”，一款HTML5跨屏前端框架 JavaScript构建工具： Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载 1.2 前后端分离史1.2.1 以后端为主的MVC时代为了降低开发的复杂度，以后端为出发点，比如:Struts2、SpringMVC等框架的使用，就是后端的MVC时代； 以SpringMVC流程为例： 发起请求到前端控制器(DispatcherServlet) 前端控制器请求HandlerMapping查找 Handler，可以根据xml配置、注解进行查找 处理器映射器HandlerMapping向前端控制器返回Hand1er 前端控制器调用处理器适配器去执行Handler 处理器适配器去执行Handler HandTer执行完成给适配器返回ModelAndview 处理器适配器向前端控制器返回ModelAndvView，ModelAndview是 SpringNvC框架的一个底层对象，包括Model和View 前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(JSP) 视图解析器向前端控制器返回View 前端控制器进行视图渲染，视图渲染将模型数据(在Mode1Andview对象中)填充到request域 前端控制器向用户响应结果 优点： MVC是一个非常好的协作模式，能够有效降低代码的耦合度，从架构上能够让开发者明白代码应该写在哪里。为了让View更纯粹，还可以使用Thymeleaf、Freemarker等模板引擎，使模板里无法写入Java代码，让前后端分工更加清晰。 缺点： 前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式： 第一种是前端写DEMO，写好后，让后端去套模板。好处是DEMO可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大； 另一种协作模式是前端负责浏览器端的所有开发和服务器端的View层模板开发。好处是UI相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。 前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是Controller ，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller本身与Mode1往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在Controller层。这些问题不能全归结于程序员的素养，否则JSP就够了。 对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用【Comet】、【BigPipe】等技术方案来优化性能。 1.2.2 基于AJAX带来的SPA时代时间回到2005年 AJAX （Asynchronous JavaScript And XML，异步JavaScript和XML，老技术新用法）被正式提出并开始使用CDN作为静态资源存储，于是出现了JavaScript 王者归来（在这之前JS都是用来在网页上贴狗皮膏药广告的）的SPA（Single Page Application）单页面应用时代。 优点： 这种模式下，前后端的分工非常清晰，前后端的关键协作点是AJAX接口。看起来是如此美妙，但回过头来看看的话，这与JSP时代区别不大。复杂度从服务端的JSP里移到了浏览器的JavaScript，浏览器端变得很复杂。类似Spring MVC，这个时代开始出现浏览器端的分层架构： 缺点： 前后端接口的约定：如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。 前端开发的复杂度控制：SPA应用大多以功能交互型为主，JavaScript代码过十万行很正常。大量JS代码的组织，与View层的绑定等，都不是容易的事情。 1.2.3 前端为主的MV*时代此处的MV*模式如下： MVC (同步通信为主) ：Model、View、Controller MVP (异步通信为主) ：Model、View、Presenter MVVM (异步通信为主) ：Model、View、ViewModel 为了降低前端开发复杂度，涌现了大星的前端框架，比如: Angular JS、React 、vue.js、EmberJS 等，这些框架总的原则是先按类型分层，比如Templates、Controllers、Models，然后再在层内做切分，如下图: 优点： 前后端职责很清晰：前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful。 前端开发的复杂度可控：前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本书的厚度去说明。 部署相对独立：可以快速改进产品体验。 缺点： 代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。 全异步，对SEO不利。往往还需要服务端做同步渲染的降级方案。 性能并非最佳，特别是移动互联网环境下。 SPA不能满足所有需求，依旧存在大量多页面应用。URL Design需要后端配合，前端无法完全掌控。 1.2.4 NodeJS带来全栈时代前端为主的MV*模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着NodeJS的兴起JavaScript开始有能力运行在服务端。这意味着可以有一种新的研发模式。 在这种研发模式下，前后端的职责很清晰。对前端来说，两个UI层各司其职： Front-end Ul layer处理浏览器层的展现逻辑。通过CSS渲染样式，通过JavaScript添加交互功能，HTML的生成也可以放在这层，具体看应用场景。 Back-end Ul layer处理路由、模板、数据获取、Cookie等。通过路由，前端终于可以自主把控URLDesign，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。 通过Node，Web Server 层也是JavaScript代码，这意味着部分代码可前后复用，需要SEO的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。 与JSP模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。 基于NodeJS的全栈模式，依旧面临很多挑战： 需要前端对服务端编程有更进一步的认识。比如TCP/IP等网络知识的掌握。 NodeJS层与Java层的高效通信。NodeJS模式下，都在服务器端，RESTful HTTP通信未必高效，通过SOAP等方式通信更高效。一切需要在验证中前行。 对部署、运维层面的熟练了解，需要更多知识点和实操经验。 大量历史遗留问题如何过渡。这可能是最大最大的阻力。 1.3 前端MVVM模式1.3.1 什么是MVVMMVVM (Model-View-ViewModel)是一种软件架构设计模式，由微软WPF（用于替代 WinForm，以前就是用这个技术开发桌面应用程序的）和Silverlight（类似于Java Applet，简单点说就是在浏览器上运行的WPF）的架构师Ken Cooper和Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由John Gossman（同样也是WPF和Silverlight的架构师）于2005年在他的博客上发表。 MVVM源自于经典的 MVC（Model-View-Controller）模式（期间还演化出了MVP（Model-View-Presenter）模式）。MVVM的核心是viewModel层，负责转换Model 中的数据对象来让数据变得更容易管理和使用，其作用如下： 该层向上与视图层进行双向数据绑定 向下与Model 层通过接口请求进行数据交互 MVVM已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的MWVM框架有vue.js，AngularJS等。 1.3.2 为什么要使用MVVMMVVM模式和MVC模式一样，主要目的是分离视图(View）和模型(Model)，有几大好处： 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可复用：你可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 1.3.3 MVVM的组成部分View： View是视图层，也就是用户界面。前端主要由HTML和CSS来构建，为了更方便地展现ViewModel或者Model层的数据，已经产生了各种各样的前后端模板语言，比如FreeMarker 、Thymeleaf 等等，各大MVVM框架如Vue.js , Angular JS，EJS 等也都有自己用来构建用户界面的内置模板语言。 Model： Model是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统—的接口规则 ViewModel： ViewModel是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。 需要注意的是ViewModel所封装出来的数据模型包括视图的状态和行为两部分，而Model层的数据模型是只包含状态的 比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示） 页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互） 视图状态和行为都封装在了ViewModel里。这样的封装使得ViewM odel可以完整地去描述View层。由于实现了双向绑定，ViewModel的内容会实时展现在View层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵DOM去更新视图。 MVVM框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护ViewModel，更新数据视图就会自动得到相应更新，真正实现事件驱动编程。 View层展现的不是Model层的数据，而是ViewModel的数据，由ViewModel负责与Model层交互，这就完全解耦了view层和 Model层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 2 概述Vue (读音/vju:/，类似于view)是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时,Vue也完全能够为复杂的单页应用提供驱动。 2.1 MVVM模式的实现者我们知道MVVM表示如下: Model：模型层，在这里表示JavaScript对象 View：视图层，在这里表示DOM（HTML 操作的元素） ViewModel：连接视图和数据的中间件，Vue.js就是MVVM中的ViewModel层的实现者 在MWVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个 observer观察者 ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新 ViewModel 能够监听到视图的变化，并能够通知数据发生改变 至此，我们就明白了，Vue.js就是一个MVVM的实现者，他的核心就是实现了DOM监听与数据绑定 2.2 为什么要使用Vue.js 轻星级，体积小是一个重要指标。Vue.,js压缩后有只有30多kb (Angular压缩后56kb+，React压缩44kb+) 移动优先。更适合移动端，比如移动端的Touch 事件 易上手，学习曲线平稳，文档齐全 吸取了Angular（模块化）和React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性 开源，社区活跃度高 2.3 Vue.js的两个核心要素2.3.1 数据驱动 当你把一个普通的JavaScript对象传给Vue实例的data选项，Vue将遍历此对象所有的属性，并使用object.defineProperty把这些属性全部转为getter/setter。O****bject.defineProperty是ES5中一个无法shim的特性，这也就是为什么Vue不支持IE8以及更低版本浏览器。 这些getter/setter对用户来说是不可见的，但是在内部它们让Vue追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时getter/setter的格式化并不同，所以你可能需要安装vue-devtools来获取更加友好的检查接口。 每个组件实例都有相应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 2.3.2 组件化 页面上每个独立的可交互的区域视为一个组件 每个组件对应一个工程目录，组件所需的各种资源在这个目录下就近维护 页面不过是组件的容器，组件可以嵌套自由组合（复用）形成完整的页面 3 第一个Vue应用程序3.1 兼容性Vue不支持IE8及以下版本，因为Vue使用了IE8无法模拟的ECMAScript 5特性。但它支持所有兼容ECMAScript 5的浏览器。 3.2 实例1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;第一个Vue应用程序&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, data:&#123; message:&quot;Hello Vue!&quot; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4 Vue实例的生命周期 5 条件渲染5.1 条件渲染语句 v-if v-else 5.1.1 HTML1234&lt;div id=&quot;app&quot;&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome&lt;/h1&gt; &lt;h1 v-else&gt;Oh no /(ㄒoㄒ)/~~&lt;/h1&gt;&lt;/div&gt; 5.1.2 JavaScript1234567var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, data:&#123; awesome: true &#125;&#125;) 5.1.3 效果awesome: true Vue is awesome awesome: false Oh no /(ㄒoㄒ)/~~ 5.2 连续判断语句 v-else-if 5.2.1 HTML123456&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;A&lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;B&lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;C&lt;/div&gt; &lt;div v-else&gt;Not A/B/C&lt;/div&gt; &lt;/div&gt; 5.2.2 JavaScript1234567var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, data:&#123; type: &#x27;A&#x27; &#125;&#125;) 5.2.3 效果略 6 列表渲染6.1 循环遍历语句 v-for 6.1.1 HTML12345&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item.message&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 6.1.2 JavaScript12345678910var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#example-1&quot;, data:&#123; items:[ &#123;message:&#x27;Foo&#x27;&#125;, &#123;message:&#x27;bar&#x27;&#125; ] &#125;&#125;) 6.1.3 效果略 7 事件处理7.1 监听事件 v-on 7.1.1 HTML123&lt;div id=&quot;example-1&quot;&gt; &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;/div&gt; 7.1.2 JavaScript123456789101112var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#example-1&quot;, data:&#123; message: &#x27;Hello Vue!!!&#x27; &#125;, methods:&#123; greet: function () &#123; alert(this.message) &#125; &#125;&#125;) 7.1.3 效果略 8 Axios实现异步通信8.1 什么是AxiosAxios是一个开源的可以用在浏览器端和NodeJS的异步通信框架，她的主要作用就是实现AJAX异步通信，其功能特点如下: 从浏览器中创建XMLHttpRequests 从node.js创建http请求。 支持promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF(跨站请求伪造) GitHub: https://github.com/axios/axios 8.2 为啥要使用Axios由于Vue.js是一个视图层框架并且作者（尤雨溪）严格准守 SoC（关注度分离原则），所以Vue.js并不包含AJAX的通信项能，为了解决通信问题，作者单独开发了一个名为vue-resource 的插件，不过在进入2.0版本以后停止了对该插件的维护并推荐了Axios框架。 8.3 第一个Axios应用程序8.3.1 JSON数据12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;百度&quot;, &quot;url&quot;: &quot;http://www.baicu.com&quot;, &quot;page&quot;:66, &quot;isNonProfit&quot;: true, &quot;address&quot;: &#123; &quot;street&quot;: &quot;海定区&quot;, &quot;city&quot;: &quot;北京市&quot;, &quot;country&quot;: &quot;中国&quot; &#125;, &quot;links&quot;: [ &#123; &quot;name&quot;: &quot;Google&quot;, &quot;url&quot;: &quot;http://www.google.com&quot; &#125;, &#123; &quot;name&quot;: &quot;Baidu&quot;, &quot;url&quot;: &quot;http://www.baidu.com&quot; &#125;, &#123; &quot;name&quot; : &quot;sougou&quot;, &quot;url&quot;: &quot;http://www.sougou.com&quot; &#125; ]&#125; 8.3.2 HTMl12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;div&gt; 名称：&#123;&#123;info.name&#125;&#125; &lt;/div&gt; &lt;div&gt; URL：&lt;a v-bind:href=&quot;info.url&quot; target=&quot;_blank&quot;&gt;&#123;&#123;info.url&#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=&quot;link in info.links&quot;&gt; &#123;&#123;link.name&#125;&#125; : &lt;a v-bind:href=&quot;link.url&quot; target=&quot;_blank&quot;&gt;&#123;&#123;link.url&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 8.3.3 JavaScript123456789101112131415161718 var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, data()&#123; return&#123; info:&#123; &#125; &#125; &#125;, mounted() &#123;//get：请求的地址//then：请求之后的处理//response：请求后得到的一个结果，包括数据data//=&gt;：lambda表达式，简约写法 axios.get(&#x27;data.json&#x27;).then(response =&gt; this.info=response.data) &#125; &#125;) 8.3.4 效果略 9 表单输入绑定9.1 什么是双向数据绑定Vue.js 是一个MVVM框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是Vue.js的精髓之处了。值得注意的是，我们所说的数据双向绑定，一定是对于UI控件来说的，非UI控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用vuex，那么数据流也是单项的，这时就会和双向数据绑定有冲突。 9.2 为什么要实现数据的双向绑定在Vue.js中，如果使用vuex，实际上数据还是单向的，之所以说是数据双向绑定，这是用的UI控件来说，对于我们处理表单，Vue.js 的双向数据绑定用起来就特别舒服了。 即两者并不互斥，在全局性数据流使用单项，方便跟踪； 局部性数据流使用双向，简单易操作。 9.3 在表单中使用双向数据绑定你可以用v-model指令在表单 &lt;input&gt;、&lt;textarea&gt;及 &lt;select&gt;元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对—些极端场景进行一些特殊处理。 v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值。它将始终将当前活动实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 10 组件基础10.1 什么是组件组件是可复用的Vue 实例，说白了就是一组可以重复使用的模板，跟STL 的自定义标签、Thymeleaf 的th:fragment以及 Sitemesh3框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织： 10.2 第一个vue组件实际开发中我们不会用这种形式写组件，而是采用 vue-cli来创建 .vue组件，仅供参考： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;第一个Vue应用程序&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;!--将for里面的item绑给组件中的props的item属性， 在bind中等号左边是子组件中的属性，等号右侧是for中遍历的item--&gt; &lt;my-component v-for=&quot;item in items&quot; v-bind:item=&quot;item&quot;&gt;&lt;/my-component&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; //注册一个组件 Vue.component(&quot;my-component&quot;,&#123; //给模板中的item绑定上可以接收父组件传来参数的属性 props:[&quot;item&quot;], template: &#x27;&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#x27; &#125;) var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, data()&#123; return&#123; items:[&quot;111&quot;,&quot;222&quot;,&quot;333&quot;] &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 11 计算属性11.1 什么是计算属性计算属性是用来声明式的描述一个值依赖了其它的值。当你在模板里把数据绑定到一个计算属性上时，Vue 会在其依赖的任何值导致该计算属性改变时更新DOM。这个功能非常强大，它可以让你的代码更加声明式、数据驱动并且易于维护。简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性)，仅此而已； 11.2 计算属性与方法的区别11.2.1 实例12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;第一个Vue应用程序&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;当前时间方法:&#123;&#123;getCurrentTime()&#125;&#125;&lt;/p&gt; &lt;!-- 这里调用的是一个值 --&gt; &lt;p&gt;当前时间属性:&#123;&#123;getCurrentTime2&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, //方法 methods:&#123; getCurrentTime:function()&#123; return Date.now(); &#125; &#125;, //计算属性 computed:&#123; getCurrentTime2:function()&#123; return Date.now(); &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12 插槽与自定义事件12.1 插槽内容Vue实现了一套内容分发的API，这套API的设计灵感源自Web Components规范草案，将 &lt;slot&gt;元素作为承载分发内容的出口。 利用插槽功能实现一个组合组件 比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢? 12.2 实现一个todo组件12.2.1 HTML123456&lt;div id=&quot;app&quot;&gt; &lt;todo&gt; &lt;todo-title slot=&quot;todo-title&quot; v-bind:title=&quot;title&quot;&gt;&lt;/todo-title&gt; &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in items&quot; v-bind:item=&quot;item&quot;&gt;&lt;/todo-items&gt; &lt;/todo&gt;&lt;/div&gt; 12.2.2 JavaScript12345678910111213141516171819202122//定义代办事项组件 Vue.component(&quot;todo&quot;,&#123; template:&quot;&lt;div&gt;&lt;slot name=&#x27;todo-title&#x27;&gt;&lt;/slot&gt;&lt;ul&gt;&lt;slot name=&#x27;todo-items&#x27;&gt;&lt;/slot&gt;&lt;/ul&gt;&lt;/div&gt;&quot; &#125;); //定义待办事项标题组件 Vue.component(&quot;todo-title&quot;,&#123; props:[&#x27;title&#x27;], template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27; &#125;); //定义待办事项内容组件 Vue.component(&quot;todo-items&quot;,&#123; props:[&#x27;item&#x27;], template:&#x27;&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#x27; &#125;); var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, data:&#123; title:&#x27;Todo-List&#x27;, items:[&quot;吃饭&quot;,&quot;睡觉&quot;,&quot;打豆豆&quot;] &#125; &#125;) 12.2.3 效果略 12.3 自定义事件子组件中调用的事件与父组件中事件的绑定，实现按钮删除父组件元素的功能。 12.3.1 HTML1234567 &lt;div id=&quot;app&quot;&gt; &lt;todo&gt; &lt;todo-title slot=&quot;todo-title&quot; v-bind:title=&quot;title&quot;&gt;&lt;/todo-title&gt;&lt;!-- 这里v-for使用的另一种写法，可以得到当前元素在集合中的位置index --&gt; &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in items&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot; v-on:remove=&quot;removeItems(index)&quot;&gt;&lt;/todo-items&gt; &lt;/todo&gt; &lt;/div&gt; 12.3.2 JavaScript12345678910111213141516171819202122232425262728293031323334 //定义代办事项组件 Vue.component(&quot;todo&quot;,&#123; template:&quot;&lt;div&gt;&lt;slot name=&#x27;todo-title&#x27;&gt;&lt;/slot&gt;&lt;ul&gt;&lt;slot name=&#x27;todo-items&#x27;&gt;&lt;/slot&gt;&lt;/ul&gt;&lt;/div&gt;&quot; &#125;); //定义待办事项标题组件 Vue.component(&quot;todo-title&quot;,&#123; props:[&#x27;title&#x27;], template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27; &#125;); //定义待办事项内容组件 Vue.component(&quot;todo-items&quot;,&#123; props:[&#x27;item&#x27;,&#x27;index&#x27;], template:&quot;&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;button @click=&#x27;remove&#x27;&gt;删除&lt;/button&gt;&lt;/li&gt;&quot;, methods:&#123; //将父组件需要的参数传出去 remove:function(index)&#123; this.$emit(&quot;remove&quot;,index) &#125; &#125; &#125;); var app = new Vue(&#123; // el : element的缩写，挂载元素 el:&quot;#app&quot;, data:&#123; title:&#x27;Todo-List&#x27;, items:[&quot;吃饭&quot;,&quot;睡觉&quot;,&quot;打豆豆&quot;] &#125;, methods:&#123; removeItems:function(index)&#123;//这里调用splice方法将数组中的元素删除，所以需要的阿斗index下标 this.items.splice(index,1) &#125; &#125; &#125;) 12.3.3 效果略 13 Vue-CLI13.1 什么是vue-clivue-cli官方提供的一个脚手架（预先定义好的目录结构及基础代码，咱们在创建Maven项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架)，用于快速生成一个 vue的项目模板。 13.1.1 主要功能 统一的目录结构 本地调试 热部署 单元测试 集成打包上线 13.1.2 环境准备 Node.js (&gt;= 6.x，首选8.x) git 13.1.3 安装vue-cli 安装Node.js 官网下载地址 http://nodejs.cn/download 安装Node.js的同时还会安装npm，类似于安装工具。 解决npm速度过慢的问题：npm config set registry https://registry.npm.taobao.org 运行 npm install -g @vue/cli 来安装vue-cli 安装完毕后，输入 vue -V 如果出现 @vue/cli 4.5.15 则说明安装成功。 13.2 使用vue-cli创建demo在命令行窗口运行 vue ui 来vue-cli的可视化窗口 然后选择对应的项目文件夹创建项目，填写项目名和包管理器： 然后预设页选择手动配置： 记得在功能页选择要添加的，比如router或者vuex，千万不要选linter： 在配置页选择vue-cli的版本： 最后完成创建，等待依赖下载完毕。 14 Webpack14.1.Webpack简介14.1.1 简介本质上，webpack是一个现代JavaScript应用程序静态模块打包器(module bundler)。当webpack处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。 14.1.2 现状伴随着移动互联网的大潮，当今越来越多的网站已经从网页模式进化到了WebApp模式。它们运行在现代浏览器里，使用HTML5、CSS3、ES6等新的技术来开发丰富的功能，网页已经不仅仅是完成浏览器的基本需求；WebApp通常是一个SPA(单页面应用)，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的JS代码，这给前端的开发流程和资源组织带来了巨大挑战。 前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 14.1.3 模块化的演进Script标签 1234&lt;script src=&quot;module1.js &quot;&gt;&lt;/scirpt&gt;&lt;script src=&quot;module2.js &quot;&gt;&lt;/scirpt&gt;&lt;script src=&quot;module3.js &quot;&gt;&lt;/scirpt&gt;&lt;script src=&quot;module4.js &quot;&gt;&lt;/scirpt&gt; 这是最原始的JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window对象中，不同模块的调用都是一个作用域。这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照 &lt;script&gt;的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonsJs 服务器端的NodeJS遵循CommonsJS规范，该规范核心思想是允许模块通过 require方法来同步加载所需依赖的其它模块，然后通过 exports或 module.exports来导出需要暴露的接口。 1234require( &quot;module&quot;);require(&quot;../module.js &quot;);export.doStuff = function() &#123;&#125;;module.exports = somevalue; 优点 服务器端模块便于重用 NPM中已轻有超过45万个可以使用的模块包。简单易用 缺点同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的。不能非阻塞的并行加载多个模块 实现 服务端的NodeJs\\ Browserify，浏览器端的CommonsJS实现，可以使用NPM的模块，但是编译打包后的文件体积较大 modules-webmake，类似 Browserify，但不如Browserify灵活 wreq，Browserify 的前身","categories":[],"tags":[]},{"title":"","slug":"Unity API","date":"2022-01-02T09:58:01.247Z","updated":"2021-03-28T05:14:16.436Z","comments":true,"path":"2022/01/02/Unity API/","link":"","permalink":"http://example.com/2022/01/02/Unity%20API/","excerpt":"","text":"Unity API https://docs.unity3d.com/cn/2018.4/Manual/UnityManual.html Unity 引擎 https://unity.cn/releases/lts/2018 2018.x最新一版 B站 2D开发demo视频教学（熟悉开发环境） https://www.bilibili.com/video/BV1V4411W787 C#语言学习 B站太多了，自己找。","categories":[],"tags":[]},{"title":"","slug":"SpringMVC","date":"2022-01-02T09:58:01.245Z","updated":"2021-10-31T05:50:49.397Z","comments":true,"path":"2022/01/02/SpringMVC/","link":"","permalink":"http://example.com/2022/01/02/SpringMVC/","excerpt":"","text":"1 概述springmvc是基于spring的一个servlet升级版，实际上是spring的一个模块，专门做web开发的。 web开发底层是servlet，框架是在servlet基础上面增加一些功能，让你做web开发方便。 SpringMVC就是一个spring容器，放的是控制器对象（Controller）。我们要做的就是使用@Controller创建控制器对象，把对象放入springmvc容器中，把创建的对象作为控制器使用，这个控制器对象能接受用户的请求，显示处理结果，就当作是一个servlet使用。 使用@Controller创建的是一个普通类对象，不是servlet。springmvc赋予了控制器对象一些额外的功能。 web开发底层是servlet，springmvc中有一个对象是servlet：DispatcherServlet。 DispatcherServlet：负责接收用户的所有请求，用户吧请求给了DispatcherServlet，之后DispatcherServlet把请求转发给我们的Controller对象，最后是Controller对象处理请求。 1.1 简介SpringMVC又称Spring Web MVC。是spring框架的一部分。 1.2 优点 基于MVC架构：功能分工明确。解耦合 容易理解，上手快，使用简单：SpringMVC是轻量级的，可以快速开发一个注解的SpringMVC项目。 作为Spring框架的一部分，能够使用Spring的IoC和Aop。方便整合其他框架 SpringMVC强化注解的使用，在控制器，Service，Dao都可以使用注解，方便灵活。 1.3 第一个注解的SpringMVC项目1.3.1 新建web maven工程这次我们创建的maven-apache-webapp骨架的项目 1.3.2 加入依赖123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.3.3 中央调度器（DispatcherServlet） DispatcherServlet叫做中央调度器，是一个servlet，它的父类是集成HttpServlet DispatcherServlet也叫做前端控制器（front controller） 负责创建springmvc容器对象，读取xml配置文件，创建文件中的Controller对象 DispatcherServlet负责接收用户提交的请求，调用其他的自定义控制器对象，并把请求的处理结果显示给用户 中央调度器（DispatcherServlet）的配置： 在web.xml中配置servlet信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 声明，注册springMvc的核心对象DispatcherServlet --&gt; &lt;!-- 需要在tomcat服务器启动时，创建DispatcherServlet对象的实例 为什么要创建实例： 因为DispatcherServlet在它创建过程中，会同时创建springMvc的容器对象， 读取springMvc的配置文件，把这个配置文件中的对象都创建好，当用户发起请求时就可以直接使用对象 servlet的初始化会执行init（）方法，DispatcherServlet在init（）中 &#123; //创建容器，读取配置文件 WebApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;); //把容器对象放入ServletContext中 getServletContext().serAttribute(key,ctx); &#125; springMvc创建对象时，读取的配置文件默认是/WEB-INF/&lt;servlet-name&gt;-servlet.xml 我们可以自定义读取配置文件的位置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;myweb&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 自定义读取配置文件的位置 --&gt; &lt;init-param&gt; &lt;!-- springMvc的配置文件的属性 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- springMvc的配置文件的自定义位置 --&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 在tomcat启动后，创建Servlet对象 --&gt; &lt;!-- load-on-startup：表示tomcat在启动后就创建对象的顺序 它的值是大于等于0的整数，值越小创建时间越早。 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;myweb&lt;/servlet-name&gt; &lt;!-- 使用框架时，url-pattern可以使用两种值 1. 使用扩展名方式，语法*.xxx, xxx是自定义的扩展名。常用方式*.do, *.action, *.mvc等等 凡是使用这种扩展名的请求都交给中央调度器管理 2. 使用斜杠&quot;/&quot; --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 1.3.4 创建发送请求的页面12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;第一个springmvc项目&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;some.do&quot;&gt;发起some.do请求&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1.3.5 创建控制器类（Controller） 在类的上面加入@Controller注解，创建对象，并放入到springmvc容器中 在类中的方法上面加入@RequestMapping注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.pjh.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/** * @Controller 创建处理器对象，对象放在springmvc容器中 * 位置：类之上 * 和spring中讲的@Service，@Component差不多 * * 能处理请求的都是控制器（处理器） */@Controllerpublic class MyController &#123; /* 处理用户提交的请求，springmvc中是使用方法来处理的。 方法是自定义的，可以有多种返回值，多种参数，方法名称自定义 */ /** * 准备使用doSome方法处理some.do请求 * @RequestMapping 请求映射，作用是把一个请求地址和一个方法绑定在一起。一个请求指定一个方法处理 * 属性：1. value是一个String，表示请求的uri地址 * value值必须是唯一的，不能重复。在使用时，推荐地址以&quot;/&quot;开头 * value值可以用花括号括起多个地址，在访问这些地址时，都是请求的该方法 * 位置：1. 在方法的上面，常用 * 2. 在类上面使用 * 说明：使用RequestMapping修饰的方法叫做处理器方法或者控制器方法 * 使用@RequestMapping是可以处理请求的，类似于Servlet中的doGet和doPost * @return ModelAndView * Model：数据，请求处理完成后，要显示给用户的数据 * View：视图，比如jsp */ @RequestMapping(value = &#123;&quot;/some.do&quot;, &quot;/first.do&quot;&#125;) public ModelAndView doSome() &#123; //创建返回mv对象 ModelAndView mv = new ModelAndView(); //添加数据，框架在请求最后把数据放入到request作用域 //request.setAttribute() mv.addObject(&quot;msg&quot;, &quot;some.do请求已处理，来自SpringMVC&quot;); mv.addObject(&quot;fun&quot;, &quot;执行的doSome方法&quot;); //指定视图，完整路径 //框架对视图执行的forward操作，即 //request.getRequestDispather().forward() //mv.setViewName(&quot;/show.jsp&quot;); //当配置视图解析器后，可以使用逻辑名称（文件名字），指定视图路径 //框架会使用视图解析器的前缀+逻辑名称+后缀 组成完整路径，这里是字符串连接操作 mv.setViewName(&quot;show&quot;); //返回mv return mv; &#125;&#125; 1.3.6 创建显示结果的页面1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;show.jsp获得的结果&lt;/h3&gt;&lt;br/&gt; &lt;h3&gt;msg:$&#123;msg&#125;&lt;/h3&gt;&lt;br/&gt; &lt;h3&gt;fun:$&#123;fun&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 1.3.7 创建springmvc的配置文件（spring的配置文件一样） 声明组件扫描器，指定@Controller注解所在的包名 声明视图解析器，帮助处理视图的。 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 声明组件扫描器 --&gt; &lt;context:component-scan base-package=&quot;com.pjh.controller&quot;/&gt; &lt;!-- 声明视图解析器，帮助开发人员设置视图文件的路径 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 前缀：视图文件的路径 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;/&gt; &lt;!-- 后缀：视图文件的拓展名 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 1.3.8 分析springmvc请求的发送过程 发起some.do tomcat ( Web.xml —- url-pattern知道*.do的请求发送给DispatcherServlet ) DispatcherServlet ( 根据springmvc.xml配置知道some.do —- doSome方法 ) DispatcherServlet把some.do转发给MyController.doSome()方法 框架执行doSome()把得到ModelAndView进行处理，转发到show.jsp 1.3.9 分析springmvc执行过程 tomcat启动，创建springmvc容器：核心在于DispatcherServlet的init方法，他会创建一个spring容器并且把它加入到ServletContext中成为全局变量 请求的处理过程：核心方法是DispatcherServlet的doDispatch方法，它会调用请求对应控制器中的对应方法 2 注解式开发2.1 @RequestMapping2.1.1 在类的上方使用属性value中，写所有请求地址的公共部分，叫做模块名称。 2.1.2 method属性可以设置请求的方式：GET、POST等 它的值是RequestMethod的枚举值，例如： 表示get请求方式，RequestMethod.GET；表示post请求方式，RequestMethod.POST； 12@RequestMapping(value = &#123;&quot;/some.do&quot;, &quot;/first.do&quot;&#125;, method = RequestMethod.GET)@RequestMapping(value = &#123;&quot;/other.do&quot;, &quot;/second.do&quot;&#125;, method = RequestMethod.POST) 没有设置该属性时，访问目标方法没有限制。 2.2 控制器处理用户参数 为方法增加上HttpServletRequest、HttpServletResponse、HttpSession的形参 直接为方法增加上请求中携带的请求参数 2.2.1 逐个接收参数12345678910111213141516171819202122232425262728293031323334353637package com.pjh.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@Controllerpublic class MyController &#123; /** * 逐个接收请求参数： * 要求：处理器方法的形参名与请求中的参数名必须一致， * 同名参数赋值给同名形参 * 框架接收请求参数： * 1. 使用request对象接收请求参数 * String strName = request.getParameter(&quot;name&quot;); * String strAge = request.getParameter(&quot;age&quot;); * 2. springMVC框架通过DisPatcherServlet 调用 MyController的doReceiveProperty()方法 * 调用方法时，按名称对应，把接收的参数赋值给形参 * doReceiveProperty(strName, Integer.parseInt(strAge)) * 框架会提供类型转换的功能，能把字符串转为int，long，float等 */ @RequestMapping(value = &quot;/receiveproperty.do&quot;) public ModelAndView doReceiveProperty(String name, int age) &#123; //可以在方法中直接使用name，age ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, name); mv.addObject(&quot;myage&quot;, age); mv.setViewName(&quot;show&quot;); return mv; &#125;&#125; 注意： 在框架进行类型转换时，可能出现无法转换的情况，例如age为空时和age不为整数时，这时服务器会阻止请求调用方法，可以用Integer替换形参int，来避免为空的情况 如果采用post请求方式，输入中文参数会出现乱码，这时需要手动设置response的encoding为utf-8，如果存在多个方法，可能就要设置多次，这时可以采用过滤器来解决重复代码。 过滤器可以自定义，也可以使用框架自带的 CharacterEncodingFilter。 在web.xml中声明字符编码过滤器： 12345678910111213141516171819202122232425&lt;!-- 注册声明过滤器，解决post乱码问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置项目中使用的字符编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 强制请求对象，使用该编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 强制应答对象，使用该编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 如果请求中的参数名和形参名称不一致，就不能得到对应的参数值，从而抛出异常。所以为了解决请求中参数名形参名不一样的问题，我们引入@RequestParam注解。 123456789101112131415161718/*** 请求中参数名和形参名不一样* @RequestParam 解决请求中参数名形参名不一样的问题* 属性：* 1. value 请求中的参数名* 2. required 是一个boolean，默认是true* 表示请求中必须包含此参数* 位置：在处理器方法的形参定义的前面*/@RequestMapping(value = &quot;/receiveparam.do&quot;)public ModelAndView doReceiveParam(@RequestParam(value=&quot;rname&quot;, required = false) String name,@RequestParam(value = &quot;rage&quot;, required = false) int age) &#123; //可以在方法中直接使用name，age ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, name); mv.addObject(&quot;myage&quot;, age); mv.setViewName(&quot;show&quot;); return mv;&#125; 2.2.2 对象参数接收12345678910111213141516171819202122232425package com.pjh.controller;import com.pjh.vo.Student;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class MyController &#123; /** * 处理器方法形参是java对象，这个对象的属性名和请求中的参数名一样 * 框架会创建形参的java对象，给属性赋值，请求中的参数是name，框架会调用setName（） * 形参可以有多个对象或者值，框架会根据请求参数，自动为形参对象创建对象并赋值 */ @RequestMapping(value = &quot;/receiveobject.do&quot;) public ModelAndView doReceiveObject(Student student) &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;myname&quot;, student.getName()); mv.addObject(&quot;myage&quot;, student.getAge()); mv.addObject(&quot;mystudent&quot;, student); mv.setViewName(&quot;show&quot;); return mv; &#125;&#125; 注意：使用对象参数接收，@RequestParam没有任何效果 2.3 处理器方法的返回值2.3.1 ModelAndViewModel储存要返回的数据，最后存到resquest里面；View储存要转发的页面，使用forward。 如果当前请求既要返回数据，又要跳转页面，使用MV是非常合适的。 但是如果只需要其中一部分（Model或者View），就有些多余了。 2.3.2 String如果只是要跳转页面，返回String是最恰当的。 如果没有@ResponseBody注解，字符串表示视图名称。 1234567891011121314151617181920212223242526272829303132333435363738package com.pjh.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;@Controllerpublic class MyController &#123; /** * 处理器方法返回String——表示逻辑视图名称，需要配置视图解析器 */ @RequestMapping(&quot;/returnString-view.do&quot;) public String doReturnview(HttpServletRequest request, String name, Integer age) &#123; System.out.println(&quot;myName: &quot; + name + &quot; myAge: &quot; + age); //可以自己手动添加数据到request request.setAttribute(&quot;myname&quot;, name); request.setAttribute(&quot;myage&quot;, age); //show 逻辑视图名称，需要项目中配置了视图解析器 //框架对视图执行forward转发操作 return &quot;show&quot;; &#125; /** * 处理器方法返回String——表示完整视图名称，此时不能配置视图解析器 */ @RequestMapping(&quot;/returnString-view.do&quot;) public String doReturnview2(HttpServletRequest request, String name, Integer age) &#123; System.out.println(&quot;myName: &quot; + name + &quot; myAge: &quot; + age); //可以自己手动添加数据到request request.setAttribute(&quot;myname&quot;, name); request.setAttribute(&quot;myage&quot;, age); //完整视图路径，项目中不能配置视图解析器 //框架对视图执行forward转发操作 return &quot;/WEB-INF/view/show.jsp&quot;; &#125;&#125; 如果有@ResponseBody注解，字符串表示数据。 文件的格式datatype应该是text/plain，此时要自行设置响应头的编码集： @RequestMapping(value = “…”, produces=”text/plain;charset=utf-8”) 2.3.3 void不能表示数据，也不能表示视图。 在处理ajax的时候可以使用void返回值。通过Responce输出数据。响应ajax请求。 ajax请求服务端返回的就是数据，和视图无关。 2.3.4 对象Object这个Object可以是Integer、String、自定义对象、Map、List等，但是不能是逻辑视图。可以使用这个对象表示的数据，响应ajax请求。 ajax主要接收json的数据格式： 首先需要加入依赖，springmvc默认使用jackson 在springmvc的配置文件中加入&lt;mvc:annotation-driven&gt;注解驱动 注意：此处的annotation-driven一定选择mvc的 在处理器上面加上@ResponseBody注解 12345678910111213141516171819202122/** * @ResponseBody * 作用：把处理器方法返回对象转为json后，通过httpServletResponse输出给浏览器 * 位置：方法的定义上面。和其他注解没有顺序先后关系 * 返回对象框架的处理流程： * 1. 框架会把返回的对象，调用框架中的ArrayList&lt;HttpMessageConverter&gt;中的每个类的canWrite()方法 * 来检查哪个HttpMessageConverter接口的实现类能处理该类型的数据 * 2. 框架会调用实现类的write()，MappingJackson2HttpMessageConverter的write()方法 * 把对象转为json，调用jackson的ObjectMapper实现转为json * 3. 框架会调用@ResponseBody把2的结果数据输出到浏览器，ajax请求处理完成 */@RequestMapping(&quot;/returnObject.do&quot;)@ResponseBodypublic Student doReturnObject(String name, Integer age)&#123; System.out.println(&quot;myName: &quot; + name + &quot; myAge: &quot; + age); //处理ajax，使用json做数据的格式 Student student = new Student(); student.setAge(age); student.setName(name); return student;&#125; 内部原理： &lt;mvc:annotation-driven&gt;注解驱动。 注解驱动实现的功能是完成java对象到json，xml，text，二进制等数据格式的转换。 该标签加入配置文件后，会自动创建HttpMessageConverter接口的7个实现类对象，包括 HttpMessageConverter接口：消息转换器 功能： 定义了java转为json，xml等数据格式的方法；这个接口有很多的实现类，这些实现类完成java对象的转换。 查看HttpMessageConverter源码，可以找到下面两个方法，是给控制器类把结果输出给浏览器时使用： 12345//canWrite：作用检查处理器方法的返回值，能不能转为mediaType表示的数据格式 boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);//write：把处理器方法的返回值对象，调用jackson中的ObjectMapper转为json字符串void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException; 常用的实现类有：StringHttpMessageConverter和MappingJackson2HttpMessageConverter。 @ResponseBody注解 放在处理器方法上面，通过Responce输出数据，响应ajax请求的。 注意： 返回List对象时，是转换成json数组再传递给浏览器 2.4 中央调度器中的url-patterntomcat本身能够处理静态资源的访问，例如html、image、js文件等。 这源于tomcat的web.xml文件有一个servlet名称是default，在服务器启动时自动创建。 它能被所有web应用使用，主要服务于静态资源文件，能够处理所有未被映射（mapping）的请求。 123456789101112131415161718&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注意，default的mapping用的是斜杠”/“，这就表示静态资源文件和未被映射的请求都由这个default处理。 如果，在自己的项目中的中央调度器中url-pattern标签中使用斜杠，会替代tomcat提供的default servlet。这就导致所有对静态资源的访问都交给中央调度器处理，但是一般情况下，它不能够处理静态资源，没有控制器对象能够处理静态资源的访问。 如果使用了斜杠，那么我们需要处理静态资源的访问请求，有两种方式： 需要在springmvc配置文件中加入&lt;mvc:default-servlet-handler/&gt;。 原理是，在加入这个标签之后，控制器会创建一个DefaultServletRequestHandler的处理器对象。 DefaultServletRequestHandler处理器对象：可以把接收的请求转发给tomcat的default这个servlet。 但是这个标签和@RequestMapping注解有冲突，所以需要加入注解驱动（见2.3.4）来解决冲突。 在配置文件中加入&lt;mvc:resources/&gt;。 原理是，加入后会创建一个ResourceHttpRequestHandler这个处理器对象。 ResourceHttpRequestHandler处理器对象：可以处理对静态资源的访问 标签有两个属性： mapping：访问静态资源的uri地址，使用通配符** location：静态资源在你的项目中的目录位置 例如：&lt;mvc:resources mapping=”/static/**” location=”/static/“/&gt; 2.5 绝对路径与相对路径地址分类： 绝对地址：带有协议名称的是绝对地址，例如http://www.baidu.com 相对地址：没有协议开头的，例如user/some.do，/user/some.do。 相对地址不能独立使用，必须有一个参考地址。通过参考地址+相对地址本身才能指定资源。 参考地址：在你的页面中，访问地址不加”/“ 斜杠的使用： “/“表示上一级目录 在前端中”/“表示服务器的根目录（localhost），在后端中表示项目的根目录 快记：前端不加”/“，后端加”/“。 参考路径： html中有一个标签&lt;base&gt; 可以指定当前页面中所有请求地址的参考地址，其中设置href属性为参考地址即可； 范例：&lt;base href= “http://localhost:8080/path/&quot;&gt; 但是由于项目的根目录可能不同，可以使用一段java代码来获取这个路径： 123String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + request.getContextPath() + &quot;/&quot;; 3 SSM整合开发终于来到了重头戏。 SSM：即SpringMVC + Spring + MyBatis SpringMVC：视图层，界面层，负责接收请求，显示处理结果的。Spring：业务层，管理Service，Dao，工具类对象的MyBatis：持久层，访问数据库的 流程图：用户发起请求&lt;=&gt;SpringMVC接收&lt;=&gt;Spring中的Service对象&lt;=&gt;MyBatis处理数据 3.1 SSM中容器的关系SSM整合也叫SSI（IBatis），整合中有容器： 第一个SpringMVC容器，管理Controller控制器对象的。 第二个Spring容器，管理Service，Dao，工具类对象 我们需要把使用的对象交给合适的容器创建、管理：把Controller还有Web开发相关的对象交给SpringMVC容器，这些Web用的对象写在Spring配置文件中。把Service，dao对象定义在Spring的配置文件中，让Spring管理这些对象。 SpringMVC容器和Spring容器是由关系的，关系已经确定好了。SpringMVC容器时Spring容器的子容器，类似于继承。在子容器中的Controller可以访问父容器中的Service对象，就可以实现Controller使用Service对象了 3.2 实现一个整合项目3.2.1 数据库准备一张名为student的表 3.2.2 新建Maven Web项目略 3.2.3 加入依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1-b03&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring and SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mysql Driver --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Connection Pool Druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2.4 写web.xml的文件 注册中央调度器DispatcherServlet 目的： 创建SpringMVC容器对象，才能创建Controller类对象 创建的是Servlet，才能接收用户的请求 注册spring的监听器ContextLoaderListener 目的： 创建Spring的容器对象，才能创建Service，Dao等对象 注册字符集过滤器 目的： 解决post请求乱码问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 中央调度器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;myWeb&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:conf/dispatcherServlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;myWeb&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:conf/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- post乱码解决方案，设置过滤器修改编码集 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 3.2.5 创建包 Controller包 Service包 Dao包 实体类(domain)包 3.2.6 配置文件 SpringMVC的配置文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- SpringMVC配置文件 --&gt; &lt;!-- 组件扫描器 --&gt; &lt;context:component-scan base-package=&quot;com.pjh.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- 注解解析器 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; Spring的配置文件 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- Spring配置文件 --&gt; &lt;!-- 声明属性文件位置 --&gt; &lt;context:property-placeholder location=&quot;classpath:conf/jdbc.properties&quot;/&gt; &lt;!-- 声明druid数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.max&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 声明sqlFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf/mybatis.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- Mybatis的映射文件扫描器，用于创建dao对象 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.pjh.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 声明service的注解所在的包名位置 --&gt; &lt;context:component-scan base-package=&quot;com.pjh.service&quot;/&gt; &lt;!-- 声明事务配置 --&gt;&lt;/beans&gt; MyBatis的主配置文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 提示日志 --&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!-- 别名 --&gt; &lt;typeAliases&gt; &lt;!-- name:实体类所在包名 --&gt; &lt;package name=&quot;com.pjh.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- sql mapper的位置 --&gt; &lt;mappers&gt; &lt;package name=&quot;com.pjh.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 数据库的属性配置文件 略 3.2.7 写代码略 3.2.8 写页面略 3.2.9 项目结构 4 SpringMVC核心技术4.1 请求重定向和转发在SpringMVC中，对请求转发和重定向进行了简化，只需要在setViewName()指定的视图前添加forward（转发）或redirect（重定向）的字段。他们有一个共同的特点：不和视图解析器合作。 总所周知： 请求转发是在服务器内进行请求的转发，只有一次请求响应过程，因此可以访问WEB-INF中被保护的资源；重定向是将请求发回给用户浏览器再访问资源，是两次请求响应过程，因此不能访问WEB-INF中的资源。 关于重定向： 框架会把Model中的简单类型数据，转成String使用，作为get请求参数使用。目的是在重定向之间的两个请求之间传递数据； 因此可以在第二个请求目标使用参数集合对象，得到请求中的参数。 4.2 异常处理以前我们使用try/catch来处理异常，往往会出现大量的冗余的try/catch代码段，操作繁琐且代码凌乱。 现在框架为你提供了简介的处理异常的方式： 框架采用的是统一，全局的异常处理。把controller中的所有异常处理都集中到一个地方。采用的是aop的思想。把业务逻辑和异常处理代码分开。解耦合。 使用两个注解： @ExceptionHandler @ControllerAdvice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.pjh.handler;import com.pjh.exception.AgeException;import com.pjh.exception.NameException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;/** * @ControllerAdvice 控制器增强（给控制器类增加功能--异常处理功能） * 位置：在类的上面 * 特点：需要在配置文件中加入组件扫描器 * @author yueyinghaibao * @date 2021/10/23 */@ControllerAdvicepublic class ClobalExceptionHandler &#123; /** * @ExceptionHandler (value = 异常的class) 表示异常的类型，当发生这个类型的异常时，由当前方法处理 */ @ExceptionHandler(value = NameException.class) public ModelAndView doNameException(Exception e) &#123; /* 异常发生处理逻辑： 1. 需要把异常记录下来，到数据库，日志文件 2. 发送通知，把异常信息通过邮件，短信，微信发送给相关人员 3. 给用户友好的提示 */ ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;姓名不能为空&quot;); mv.addObject(&quot;ex&quot;, e); mv.setViewName(&quot;error&quot;); return mv; &#125; @ExceptionHandler(value = AgeException.class) public ModelAndView doAgeException(Exception e) &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;年龄不能为空&quot;); mv.addObject(&quot;ex&quot;, e); mv.setViewName(&quot;error&quot;); return mv; &#125; /** * 处理其他不知名的异常 */ @ExceptionHandler public ModelAndView doOtherException(Exception e) &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;发生错误&quot;); mv.addObject(&quot;ex&quot;, e); mv.setViewName(&quot;error&quot;); return mv; &#125;&#125; 4.3 拦截器 拦截器是SpringMVC中的一种，需要实现HandlerIntercepter接口 拦截器给过滤器类似，功能方向侧重点不同。过滤器是用来过滤请求参数的，设置编码字符集等工作。 拦截器是拦截用户的请求，做请求要做判断处理的。 拦截器是全局的，可以对多个Controller做拦截。 一个项目种可以由0个或多个拦截器，一起拦截用户的请求。 拦截器常用在：用户登陆处理，权限检查，记录日志。 一个过滤器可以拦截多个用户请求，也是aop思想 使用步骤： 定义类实现HandlerInterceptor接口 在springmvc配置文件中，声明拦截器，让框架知道拦截器的存在 拦截器的执行时间： 在请求处理之前，也就是controller类中的方法执行之前先被拦截。 在控制器方法执行之后也会执行拦截器 在请求处理完成后也会执行拦截器","categories":[],"tags":[]},{"title":"","slug":"Spring","date":"2022-01-02T09:58:01.242Z","updated":"2021-10-05T09:38:06.071Z","comments":true,"path":"2022/01/02/Spring/","link":"","permalink":"http://example.com/2022/01/02/Spring/","excerpt":"","text":"Spring1 总体概述出现在2002左右，解决企业开发难度，减轻对项目模块之间的管理，类和类之间的管理，帮助开发人员创建对象，管理对象之间的关系；能实现模块之间，类之间的解耦合。 spring核心技术：ioc，aop。 依赖：classA中使用classB的属性和方法，叫做classA依赖classB 优点： 轻量：spring框架使用jar比较少，核心功能所需jar总共3m左右；运行占用资源少，运行效率高。不依赖其他jar 针对接口编程，解耦合：IOC AOP编程的支持：AOP 方便集成各种优秀框架 Spring体系结构： 2 IoC控制反转2.1 对IoC及Spring的概念解释和实现原理IoC（Inversion of Control）：控制反转，是一个理论，概念，思想。 作用是：把对象的创建，赋值，管理工作交给代码之外的容器实现，也就是对象的创建是由其他外部资源完成 对几个关键词的描述： 控制：创建对象，对象的属性赋值，对象之间的关系管理。 反转：把原来开发人员管理，创建对象的权限转移给代码之外的容器实现，由容器代替开发人员管理对象。创建对象，给属性赋值。 正转：由开发人员在代码中，使用new构造方法创建对象，开发人员主动管理对象 容器：是一个服务器软件，一个框架（Spring） 为什么使用IoC：目的就是减少代码的改动，也能实现不同的功能，实现解耦合 IoC的体现： Servlet： 创建类继承HttpServlet。 在web.xml注册servlet。 没有自己创建Servlet对象。 Servlet对象是Tomcat服务器为你创建并管理的。 Tomcat也称为容器，其中存放着Servlet对象，Listener，Filter对象。 DI（Dependency Injection）： DI是IoC的技术实现，即依赖注入。 只需要在程序中提供需要使用的对象名称就可以了，致于对象如何在容器中创建，赋值，茶轴都由容器内部实现 Spring使用DI实现了IoC的功能，spring底层创建对象，使用的反射机制。 2.2 Spring的第一个程序2.2.1 创建maven项目在学习过程中，我们只需要最基础的部分，因此选择quickstart模板作为maven项目来创建 2.2.2 加入maven的依赖加入Spring的依赖和junit依赖。 123456789101112131415161718&lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2.3 创建类（接口和实现类）此处我创建了一个名为OneService的接口及其实现类OneServiceImpl。 123456789101112131415161718package com.pjh.service;public interface OneService &#123; void doSome();&#125;//以上接口，分割线，以下实现类package com.pjh.service.impl;import com.pjh.service.OneService;public class OneServiceImpl implements OneService &#123; @Override public void doSome() &#123; System.out.println(&quot;doSome已执行...&quot;); &#125;&#125; 2.2.4 创建spring需要使用的配置文件在配置文件中声明类的信息，这些类由spring创建和管理。 spring配置文件应当创建在resource目录下 这里提供一个标准spring配置文件模板（注解内容非必须）（XML） 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;&lt;!-- spring配置文件： 1. beans: 是根标签，spring把java对象变成bean 2. spring-beans.xsd: 是约束文件，和mybatis指定dtd是一样的--&gt; 然后我们需要在配置文件中声明java对象 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 告诉spring创建对象 声明bean，就是告诉spring要创建某个类的对象 id: 对象的自定义名称，唯一值。spring通过这个名称找到对象 class: 类的全限定名称（不能是接口，因为spring是反射机制，不能用接口） 如此，spring就完成OneService的对象创建: oneService spring是把创建好的对象放入到map中，spring框架有一个map存放对象。springMap,put(id, 对象) 一个bean标签声明一个对象 --&gt; &lt;bean id=&quot;oneService&quot; class=&quot;com.pjh.service.impl.OneServiceImpl&quot;/&gt; &lt;/beans&gt; 2.2.5 测试spring创建对象在你的测试类中： 1234567891011121314@Testpublic void testDoSomeBySpring() &#123; //使用spring容器创建的对象 //1. 指定spring配置文件的名称 String config = &quot;beans.xml&quot;; //2. 创建表示spring容器的对象，ApplicationContext //ClassPathXmlApplicationContext: 表示从类路径中加载spring的配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(config); //3. 从容器中获取某个对象，需要调用getBean方法 //传入配置文件中的id OneService one = (OneService) ac.getBean(&quot;oneService&quot;); //4. 使用创建好的对象 one.doSome();&#125; 2.2.6 一些思考对象是在什么时机创建的？ 在执行加载spring的配置文件时创建的，见2.2.5 第8行代码。且会创建配置文件中声明的所有对象。 如何获取容器中对象的信息？ 获取对象数量信息： 调用getBeanDefinitionCount()方法，返回对象的数量。 获取所有对象的名称（key）： 调用getBeanDefinitionNames()方法，返回一个字符串数组。 spring能创建非自定义的对象吗？ 可以，只需要见类的全限定名称书写正确，就可以创建任意指定的类对象。 2.3 基于XML（配置文件）的DI即通过配置文件对对象赋值。 DI：依赖注入，表示创建对象，给属性赋值。 其实现语法有两种： 在spring配置文件中，通过标签和属性完成，叫做基于XML的DI实现（见本章2.3） 使用spring中的注解，完成属性赋值，叫做基于注解的DI实现（见2.4） 2.3.1 DI的语法分类 set注入：spring调用类的set方法，在set方法可以实现属性的赋值，比较常用 构造注入：spring调用类的有参数构造方法，创建对象。在构造方法中完成赋值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 给属性赋值 --&gt; &lt;!-- 简单类型：spring中规定Java的基本数据类型和string都是简单数据类型。 1.set注入：spring调用类的set方法 简单类型set注入语法： &lt;bean id=&quot;xx&quot; class=&quot;xx&quot;&gt; &lt;property name=&quot;属性名&quot; value=&quot;值&quot;&gt; &lt;property name=&quot;另一个属性名&quot; value=&quot;另一个值&quot;&gt; ... &lt;/bean&gt; 引用类型注入语法： &lt;bean id=&quot;xx&quot; class=&quot;xx&quot;&gt; &lt;property name=&quot;属性名&quot; ref=&quot;bean的id&quot;&gt; &lt;/bean&gt; 2.构造注入：spring调用类有参数构造方法，在创建对象时，在构造方法给顺序赋值 构造注入使用&lt;constructor_arg&gt;标签 &lt;constructor_arg&gt;标签：一个标签标识方法的一个参数 &lt;constructor_arg&gt;标签属性： name:表示构造方法的形参名 index:表示构造方法的参数得位置，参数从左往右位置时从0开始，可以 以上两个属性都可以省略，但赋值时需要案找0，1，2的顺序 value:构造方法的形参类型时简单类型，使用value ref:构造方法的形参类型是引用类型，使用ref --&gt; &lt;!-- set注入 --&gt; &lt;bean id=&quot;mySchool&quot; class=&quot;com.pjh.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;西柚&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;新都区&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent&quot; class=&quot;com.pjh.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;property name=&quot;school&quot; ref=&quot;mySchool&quot;/&gt; &lt;/bean&gt; &lt;!-- 构造注入 --&gt; &lt;bean id=&quot;mySchool&quot; class=&quot;com.pjh.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;西柚&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;新都区&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent&quot; class=&quot;com.pjh.Student&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;18&quot;/&gt; &lt;constructor-arg name=&quot;school&quot; ref=&quot;mySchool&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 注意： set方法必须符合命名规范 即使没有属性，只要存在setXXX的方法，就可以通过set注入调用 必须存在set方法，否则无法执行 set注入实际上只是调用了set方法，即使不进行赋值 Spring会先执行无参构造方法，再执行set注入 在set注入时，所有的值（value）不管是数字还是其他都必须放在引号中，这是XML规范所限制的 在spring里创建对象无需在意顺序，原理似乎是二次扫描可以保证每个对象都被正确的创建 为对象赋值时也无需在意赋值顺序 2.3.2 引用类型属性自动注入 byName属性： java类中引用类型的属性名和spring容器中（配置文件）&lt;bean&gt;的id名称一致，且数据类型是一致的，这样的容器中的bean，spring能够赋值给引用类型。 123456789&lt;bean id=&quot;student&quot; class=&quot;com.pjh.Student&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;school&quot; class=&quot;com.pjh.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;西柚&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;新都区&quot;/&gt;&lt;/bean&gt; byType:java类中引用类型的数据类型和spring容器中（配置文件）&lt;bean&gt;的class属性是同源关系，这样的bean可以赋值给引用类型。 同源就是一类的意思: java类中引用类型的数据类型和class类型的值是一样的 java类中引用类型的数据类型和class类型的值是父子关系 java类中引用类型的数据类型和class的值接口和实现类关系 语法： 123456789&lt;bean id=&quot;student&quot; class=&quot;com.pjh.Student&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;/&gt;&lt;/bean&gt;&lt;!--即使名称不一致，也可以直接引用--&gt;&lt;bean id=&quot;mySchool&quot; class=&quot;com.pjh.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;西柚&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;新都区&quot;/&gt;&lt;/bean&gt; 注意： 符合条件的对象仅能存在一个，出现多个符合的bean会报错 2.3.3 为什么要使用多个配置文件 便于管理： 当项目较大时，往往存在成百上千个对象，如果全部存在一个配置文件里，不仅难以查找修改，文件的大小也会变得十分庞大，打开配置文件和保存配置文件时都会变慢。 便于多人协同开发： 避免在多人合作开发时，出现错误覆盖、模块功能冲突等情况。 因此，在开发大型项目时，可以采用一个模块一个配置文件的做法，不仅可以使配置文件小很多、提高效率，还可以让负责该模块的开发人员不与其他人员产生冲突。 2.3.4 配置文件的包含关系（套娃）在上一小节中我们讨论了为什么要使用多个配置文件，这一节我们将学习如何管理多个配置文件，于是这里涉及到了关于配置文件的包含关系。 注意：以下代码都仅保留了关键代码作为示例 当前存在两个模块Student模块和School模块，且分别拥有spring_student和spring_school配置文件，两个配置文件中分别声明了一个bean。 123456789101112&lt;!-- spring_school --&gt;&lt;bean id=&quot;school&quot; class=&quot;com.pjh.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;北京大学&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;海淀区&quot;/&gt;&lt;/bean&gt;&lt;!-- spring_student --&gt;&lt;bean id=&quot;myStudent&quot; class=&quot;com.pjh.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 我们可以创建一个total的主配置文件来管理这些模块配置文件。 123456789101112131415161718&lt;!-- total --&gt;&lt;!-- 包含关系的配置文件： total表示主配置文件：包含其他的配置文件，主配置文件一般是不定义对象的 语法：&lt;import resource=&quot;其他配置文件的路径&quot;/&gt; 关键字：&quot;classpath:&quot;表示类路径（class文件所在的目录）， 在spring的配置文件中要指定其他文件的位置， 需要使用classpath，告诉spring到哪里取加载读取文件--&gt;&lt;!-- 加载的是文件列表 --&gt;&lt;import resource=&quot;classpath:spring_school.xml&quot;/&gt;&lt;import resource=&quot;classpath:spring_student.xml&quot;/&gt;&lt;!-- 使用通配符（*：表示任意字符） 主配置文件不能包含在通配符的范围内，不要命名为spring_total--&gt;&lt;import resource=&quot;classpath:spring_*.xml&quot;/&gt; 2.4 基于注解的DI通过注解完成Java对象的创建和属性赋值。 使用注解的步骤： 加入maven的依赖spring-context，在你加入spring-context的同时，会间接加入spring-aop的依赖 使用注解必须使用spring-aop的依赖 在类中加入spring的注解（多个不同功能的注解） 在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置 需要学习的注解： @Component @Respotory @Service @Controller @Value @Autowired @Resource 2.4.1 @Component的使用首先创建一个类，并在其中使用注解@Component 1234567891011121314151617181920212223242526272829303132333435363738394041package com.pjh.ba01;import org.springframework.stereotype.Component;/** * @Component 创建对象的，等同于&lt;bean&gt;的功能 * @value 就是对象的名称，也就是bean的id，其值是唯一的，创建的对象在整个spring容器中就一个 * * 该注解使用在类的上面 * * @Component(value = &quot;myStudent&quot;) 等同于 * &lt;bean id=&quot;myStudent&quot; class=&quot;com.pjh.ba01.Student&quot;/&gt; */@Component(value = &quot;myStudent&quot;)//当我们只填入value的值，其实是可以省略的，并且在平时更加常见//OR @Component(&quot;myStudent&quot;)//我们也可以不指定对象的名称，由spring指定默认名称，其默认值为类名的lowcase格式，即student//OR @Componentpublic class Student &#123; private String name; private String age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(String age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&#x27;&quot; + age + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 然后创建一个配置文件，并在其中使用组件扫描器component-scan。 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 声明组件扫描器component-scan,组件就是java对象 base-package:指定注解在你的项目中的包名 component-scan工作方式：spring会扫描遍历base-package指定的包， 吧包中和子包中的所有类，找到类中的注解，按照注解的功能创建对或给属性赋值 加入了component-scan标签，配置文件的变化： 1. 加入了一个新的约束文件spring-context.xsd 2. 给这个新的约束文件起了命名空间的名称 --&gt; &lt;context:component-scan base-package=&quot;com.pjh.ba01&quot; /&gt;&lt;/beans&gt; 此时已经完成了在spring容器中创建java对象的目的，我们可以调用这个对象。 1234567891011121314151617181920212223package com.pjh;import com.pjh.ba01.Student;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author yueyinghaibao * @date 2021/9/25 */public class MyTest &#123; @Test public void test01() &#123; String config = &quot;applicationContext.xml&quot;; ApplicationContext context = new ClassPathXmlApplicationContext(config); Student myStudent = (Student) context.getBean(&quot;myStudent&quot;); //OR Student myStudent = (Student) context.getBean(&quot;student&quot;); System.out.println(&quot;myStudent = &quot; + myStudent); &#125;&#125; 可以得到myStudent = Student{name=’null’, age=’null’}的结果顺带一提，此时spring是调用的student类的无参构造方法 2.4.2 与Component具有相同功能的注解 @Repository（放在持久层）：放在dao的实现类上，表示创建dao对象，dao对象是能访问数据库的。 @Service（放在业务层）：放在service的实现类上，表示创建service对象，service对象是做业务处理， 可以有事务功能。 @Controller（放在控制器）：放在controller类上的，表示创建controller对象，controller对象能够接受用户提交的参数，显示请求的处理结果。 以上三个注解的使用语法和Component一样。都能创建对象，但这三个注解有额外功能。 这三个注解是给项目的对象分层的。 非这三类的对象应该使用Component。 2.4.3 component-scan扫描多个包的方式 多次使用扫描器，指定不同的包 使用分隔符（ ; OR , ）分割多个包名 指定一个父包，可以包含父包中的所有子包 2.4.4 @Value的使用此标签用于给简单类型的属性赋值。 1234567891011121314151617181920212223242526272829303132333435package com.pjh.ba02;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(&quot;myStudent&quot;)public class Student &#123; /** * @Value 给简单类型赋值 * 属性：value 是String类型，表示简单类型的属性值 * 位置：1.在属性定义的上方，无需set方法，推荐使用 * 2.在set方法上面 */ @Value(&quot;张飞&quot;) private String name; @Value(&quot;20&quot;) private String age;// public void setName(String name) &#123;// this.name = name;// &#125;//// public void setAge(String age) &#123;// this.age = age;// &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&#x27;&quot; + age + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 2.4.5 @Autowired的使用自动注入实现引用类型的属性赋值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.pjh.ba03;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(&quot;myStudent&quot;)public class Student &#123; @Value(&quot;张飞&quot;) private String name; @Value(&quot;20&quot;) private int age; /** * 引用类型 * @Autowired spring框架提供的注解，实现引用类型的赋值 * spring中通过注解给引用类型赋值，使用的是自动注入原理，支持byName和byType * 默认使用byType * 位置：1.在属性定义上，无需set方法，推荐使用 * 2.在set方法上面 * * 属性：required 是一个boolean类型的，默认true * required = true：表示引用类型赋值失败，程序报错，并终止执行。 * required = false：表示引用类型赋值失败，程序正常执行，并且赋值为null。 * * 如果要使用byName方式，需要做的是： * 1.在属性上面加入@Autowired * 2.在属性上面加入@Qualifier(value = &quot;bean的id&quot;)：表示使用指定名称的bean完成赋值 */// @Autowired// private School school1; @Autowired @Qualifier(&quot;mySchool&quot;) private School school2; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, school=&quot; + school2 + &#x27;&#125;&#x27;; &#125;&#125; 注意： 关于required的true OR false问题，更加推荐使用true。原因在于如果你的程序出现问题，会更早暴露你的问题，方便你尽快修改程序问题。 2.4.6 @Resource的使用该注解是由jdk提供的自动注入注解，作用与autowire一样 1234567891011121314151617181920212223242526272829303132333435363738package com.pjh.ba06;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component(&quot;myStudent&quot;)public class Student &#123; @Value(&quot;张飞&quot;) private String name; @Value(&quot;20&quot;) private int age; /** * 引用类型 * @Resource 来自jdk中的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值 * 使用的也是自动注入的原理，支持byName，byType，默认是byName * 位置：1.在属性定义的上面，无需set方法，推荐使用 * 2，在set方法上面 * 默认使用byName：先使用byName自动注入，如果buName失败，在使用byType * 如果想指定只使用byName，需要增加一个属性 name * name是bean的id */ @Resource(name = &quot;mySchool&quot;) private School school; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, school=&quot; + school + &#x27;&#125;&#x27;; &#125;&#125; 2.5 XML和注解该使用哪种方式XML的优势： 使用xml配置文件可以方便的修改属性的值，不需要改动类 XML的劣势： 需要写的代码太多，开发比较繁琐 由于赋值和类完全分离，所以在浏览类代码时，完全不清楚其属性值的内容 注解的优势： 使用方便，不需要写很多的代码 注解的劣势： 注解和源代码不宜分开，在需要改动时非常麻烦 注解对源代码的结构是破坏性的（O~O！） 总的来说：如果需要经常变动属性值，推荐用XML；如果属性值相对固定，推荐使用注解 并且当前的趋势是，以注解为主，XML配置文件为辅。 2.6 一个小技巧在注解中使用 ${}，通过properties配置文件实现解耦合。 需要在配置文件中用&lt;context:property-placeholder location=”文件位置”/&gt;标签读取配置文件。 3 AOP面向切面编程3.1 动态代理3.1.1 代理模式： 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 假设你有a类，想要调用c类的方法，但是c类禁止a类调用它的方法，因此可以在a和c中间创建一个b代理，让b来访问c。此时，可以通过a访问b、b再访问c的过程，达到a类调用c方法的效果。 使用代理模式的作用： 功能增强：在你原有的功能上，增加了新的额外的功能 控制访问：代理类不让你直接访问目标 减少代码的重复 专注于业务逻辑代码 解耦合 实现代理的方式： 静态代理： 代理类是自己手工实现的，自己创建一个java类，表示代理类。同时你所要代理的目标类是确定的。 特点：实现简单、容易理解 功能：目标方法调用、功能增强 缺陷：当目标类增多，代理类也会成倍增加，代理类数量过多；接口中增加或修改功能，需要修改大量的目标类和代理类。 动态代理： 在程序执行过程中，使用jdk的反射机制，创建代理对象，并动态的指定要代理的目标类。 特点： 在静态代理中目标类很多时，可以使用动态代理，避免静态代理的缺点。 动态代理中目标类即使很多，代理类数量却可以很少，当你修改接口中的方式时，不会影响代理类。 动态代理的实现分类： jdk动态代理：使用java反射包中的类和接口实现动态代理的功能。必须实现接口。 cglib动态代理：是第三方的工具库，创建代理对象。 cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中重写父类中的同名方法，实现功能的修改。因为cglib是继承，重写方法，所以要求目标类不能是final的，方法也不能是final的。 3.1.2 jdk动态代理： 反射：method类表示方法。通过Method可以执行某个方法。 实现： 反射包java.lang.reflect，里面有三个类：InvocationHandler，Method，Proxy InvocationHandler接口（调用处理器）：就一个方法invoke（） invoke：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在其中。 怎么使用这个接口：创建类实现接口InvocationHandler；重写invoke方法，把原来静态代理中代理类要完成的功能，写在invoke中。 Method类（方法）：目标类中的方法。通过Method可以执行目标类方法。 Proxy类：核心对象，作用是创建代理对象。 方法：静态方法 newProxyInstance（），创建代理对象。它有三个参数 ClassLoader loader类加载器，通过反射a.class,getClassLoader()获得 Class&lt;?&gt;[] interfaces：接口，目标对象实现的接口，也用反射获得 InvocationHandler h：自己写的，代理类要实现的代码 返回值就是一个代理对象。 3.2 AOP是什么东西3.2.1 概述AOP（Aspect Orient Programming），面向切面编程。面向切面编程是从动态角度考虑程序运行过程。 AOP底层，就是采用动态代理模式实现的，采用了两种代理：JDK动态代理和CGLIB动态代理。 AOP就是动态代理的规范化，把动态代理的实现步骤、方法都定义好了，让开发人员可以使用统一的方式。 3.2.2 如何理解面向切面编程 需要分析项目功能时，找出切面 合理安排切面的执行时间（在目标方法前，还是目标方法后） 合理的安排切面执行的位置，在哪个类，哪个方法增加功能 关键术语： Aspect：切面，给你的目标类增加非业务的功能，就是切面。 特点：一般都是非业务方法，独立使用。 常见切面功能：日志，事务，统计信息，参数检查，权限验证。 Advice 通知，通知表示切面功能执行的时间 JoinPoint 连接点，连接业务方法和切面的位置。就是某类中的业务方法 PointCut 切入点，指多个连接点方法的集合。多个方法 一个切面的三个关键要素： 切面的功能代码，切面干什么 切面的执行位置，使用PointCut表示切面执行的位置 切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后 3.3 AOP的实现aop是一个规范，时动态的一个规范化，一个标准 aop的技术实现框架： spring：spring在内部实现了aop主要在事务处理时使用，我们项目开发中很少使用，因为比较笨重 aspectJ：是eclipse的一个开源框架。spring中集成了aspectJ框架。 aspectJ框架实现aop的两种方式： 使用xml的配置文件：配置全局事务 使用注解，我们在项目中要做aop功能，一般都使用注解。aspectJ有5种注解。 3.3.1 学习aspectJ框架 切面的执行时间，这个执行时间在规范中叫做Advice（通知，增强） 在aspect框架中注解表示： @Before @AfterReturning @Around @AfterThrowing @After 切面执行的位置，使用的是切入点表达式。 其中可以使用以下字符： 3.3.2 aspectJ使用步骤 新建maven项目：quick_start 加入依赖： spring依赖 aspectJ依赖 junit依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建目标类 123456789101112131415161718package com.pjh.ba01;public interface SomeService &#123; void doSome(String name, Integer age);&#125;//上为接口，下为实现类package com.pjh.ba01;public class SomeServiceImpl implements SomeService&#123; @Override public void doSome(String name, Integer age) &#123; //给目标类增加一个执行时间的功能 System.out.println(&quot;==== 目标方法doSome() ====&quot;); &#125;&#125; 创建切面类：普通类 1234567891011121314151617181920212223242526272829303132333435363738package com.pjh.ba01;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import java.util.Date;/** * @Aspect 是aspectJ框架中的注解。 * 作用：表示当前类是切面类 * 切面类：用来给业务方法增加功能的类，在这个类中有切面的功能代码 * 位置：在类定义的上面 */@Aspectpublic class MyAspect &#123; /** * 定义方法：方式是实现切面功能的 * 方法的定义要求： * 1. 公共方法public * 2. 方法没有返回值 * 3. 方法名称自定义 * 4. 方法可以有参数，也可以没有，如果有参数，参数是有规范的 * * @Before 前置通知注解 * 属性：value，是切入点表达式，表示切面的功能执行的位置。 * 位置：在方法上面 * 特点： * 1. 在目标方法之前先执行 * 2. 不会改变目标方法的执行结果 * 3. 不会影响目标方法的执行 */ @Before(value = &quot;execution(void com.pjh.ba01.SomeServiceImpl.doSome(String,Integer))&quot;) public void myBefore() &#123; System.out.println(&quot;==== 切面功能：输出执行时间 ====&quot;); System.out.println(new Date()); &#125;&#125; 声明spring的配置文件：声明对象，将对象交给容器管理 声明目标对象 声明切面类对象 声明aspectJ框架中的自动代理生成器标签。 自动代理生成器：用来完成代理对象的自动创建功能的。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 将对象交由spring容器统一管理 --&gt; &lt;!-- 声明目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.pjh.ba01.SomeServiceImpl&quot;/&gt; &lt;!-- 声明切面对象 --&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.pjh.ba01.MyAspect&quot;/&gt; &lt;!-- 声明自动代理生成器 使用aspectJ框架内部功能，创建目标对象的代理对象。 创建代理对象是在内存中实现的，修改目标对象的内存中的结构，创建为代理对象， 所以目标对象就是修改后的代理对象 aspectj-autoproxy：会把spring容器中的所有的目标对象，一次性都生成代理对象 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 创建测试类，从spring容器中获取目标对象（实际是代理对象） 执行代理方法，实现aop的功能增强。 12345678910111213141516@Testpublic void Test01() &#123; String config = &quot;applicationContext.xml&quot;; ApplicationContext context = new ClassPathXmlApplicationContext(config); //com.sun.proxy.$Proxy: jdk动态代理 SomeService proxy = (SomeService) context.getBean(&quot;someService&quot;); proxy.doSome(&quot;lisi&quot;, 20);&#125;/*** 输出结果如下：* * ==== 切面功能：输出执行时间 ====* Sun Oct 03 16:41:02 CST 2021* ==== 目标方法doSome() ====*/ 3.3.3 JoinPoint参数即通知方法的参数中可选的一项。 其表示一个要加入切面功能的业务方法。 作用是：可以在通知方法中获取方法执行时的信息，例如方法名称，方法的实参。 如果你的切面功能中需要用到方法的信息，就加入JoinPoint。 这个JoinPoint参数的值，是由框架赋予的，帮你叙事第一个位置的参数。 JoinPoint的几个方法： getSignature()：获得方法的签名(定义) getArgs(): 获得方法的实参，其返回一个obj数组表示方法的所有实参。 3.3.4 五种注解 @Before：前置通知 定义要求： 公共方法 方法没有返回值 方法名称自定义 方法可以有参数，可以没有，如果有参数请见3.3.3 属性：value，是切入点表达式，表示切面的功能执行的位置。 位置：在方法上面 特点： 在目标方法之前先执行 不会改变目标方法的执行结果 不会影响目标方法的执行 @AfterReturning：后置通知 定义要求： 公共方法 方法没有返回值 方法名称自定义 方法有参数，推荐Object，参数名自定义 属性： value 切入点表达式 returning 自定义变量，表示目标方法的返回值；自定义变量名必须和通知方法的形参名一样 位置：在方法定义之上 特点： 在目标方法之后执行 能够获取目标方法的返回值，可以根据这个返回值做不同的处理功能 可以修改这个返回值 @Around：环绕通知 定义格式： public 必须有一个返回值，推荐Object 方法名称自定义 方法有固定参数 ProceedingJoinPoint 属性：value 切入点表达式 位置：在方法定义上面 特点： 它是功能最强的通知 它能在目标方法前后都能增强功能 控制目标方法是否被调用执行 修改原来的目标方法的执行结果，影响最后的调用结果 相当于jdk的动态代理，InvocationHandler 参数：ProceedingJoinPoint，继承于joinPoint，作用等同于method 作用：执行目标方法 返回值：就是目标方法的执行结果，可以被修改 @AfterThrowing：异常通知 定义格式： public 没有返回值 方法名称自定义 方法有一个Exception参数，如果还有就是JoinPoint 属性： value 切入点表达式 throwing 自定义变量，表示目标方法抛出的异常对象。变量名必须和方法的参数名一样 特点： 在目标方法抛出异常时执行 可以做异常的监控程序，监控目标方法执行时是不是有异常 @After：最终通知 定义格式： public 没有返回值 方法名称自定义 方法没有参数，如果有就是JoinPoint 属性：value 切入点表达式 位置：在方法上面 特点： 总是会执行 在目标方法之后执行 @Pointcut：定义切入点 五种注解有六个不是常识吗（X） 作用：用来定义和管理切入点，如果你的项目中有多个切入点表达式时重复的，可以复用的，可以使用@Pointcut。 属性：value 切入点表达式 位置：在自定义方法的上面 特点：当使用@Pointcut定义在一个方法的上面，此时这个方法的名称就是切入表达式的别名，其他通知中，value属性就可以使用这个方法名称，代替切入点表达式了，记得方法后面要加括号。 3.3.5 如果目标类不是接口的实现类（没有接口）aspectJ会使用cglib，采用继承的方式实现动态代理。 当然有接口也可以使用cglib方式，只要目标类不是final。 方法是： 在spring的配置文件中，将&lt;aop:aspectj-autoproxy/&gt;改为&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt; 4 Spring集成MyBatis使用IoC技术，它能把mybatis和spring集成在一起，像一个框架一样。 因为IoC能创建对象，可以把mybatis框架中的对象交给spring统一管理，开发人员从spring中获取对象。 开发人员就不用同时面对两个或者多个框架了。 4.1 回顾一下MyBatis使用步骤： 定义dao接口，StudentDao 定义mapper文件，StudentDao.xml 定义mabatis主配置文件，mybatis.xml 创建dao的代理对象，StudentDao dao = SqlSession.getMapper(StudentDao.class); 查询数据库，List&lt;Student&gt; students = dao.selectStudents(); 要使用dao对象，需要使用SqlSession的getMapper方法，因此我们需要： 获取SqlSession对象，需要使用SqlSessionFactory的openSession对象 创建SqlSessionFactory对象。通过读取mybatis的主配置文件，能创建SqlSessionFactory对象 需要SqlSessionFactory对象，使用Factory能获取SqlSession，有了SqlSession就能有dao，目的就是获取dao对象。Factory的创建需要读取主配置文件： 1234567891011121314151617&lt;!-- 数据库信息 --&gt;&lt;environment id=&quot;test2&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.pwd&#125;&quot;/&gt; &lt;/dataSource&gt;&lt;/environment&gt;&lt;!-- mapper文件位置 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/pjh/dao/StudentDao.xml&quot;/&gt;&lt;/mappers&gt; 由于mybatis自带的连接池不够强力，所以我们使用其他强力的连接池代替它默认的，把这个连接池也交给spring创建。 4.2 我们需要spring做什么通过4.1的说明，我们需要让spring创建一下对象 独立的连接池类对象，使用阿里的druid连接池 SqlSessionFactory对象 创建出dao对象 我们需要学习的就是创建这三个对象的语法，使用xml的bean标签。 4.3 整合创建项目步骤： 新建maven项目 加入maven依赖 spring依赖 mybatis依赖 mysql驱动 spring事务依赖 mybatis和spring集成依赖：mybatis官方提供，用来在spring项目中创建mybatis的SqlSessionFactory，dao对象的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建实体类 创建dao接口和mapper文件 创建mybatis主配置文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 提示日志 --&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!-- 别名 --&gt; &lt;typeAliases&gt; &lt;!-- name:实体类所在包名 --&gt; &lt;package name=&quot;com.pjh.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- sql mapper的位置 --&gt; &lt;mappers&gt; &lt;package name=&quot;com.pjh.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建Service接口和实现类，属性是dao 创建spring的配置文件：声明mybatis的对象交给spring创建 数据源DataSource SqlSessionFactory Dao对象 声明自定义的service 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 读取配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 声明数据源DataSource对象，作用是连接数据库 --&gt; &lt;bean id=&quot;myDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- set注入给DruidDataSource提供连接数据库的信息 --&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot;/&gt; &lt;!-- druid还有更多细分的设置项，但一般来说，设置这四项已经足够了，详情请查询druid的github wiki --&gt; &lt;/bean&gt; &lt;!-- 声明mybatis提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- set注入给sqlSessionFactory提供数据源和mybatis主配置文件位置的信息 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 声明Dao对象,使用SqlSession的getMapper --&gt; &lt;!-- MapperScannerConfigurer：在内部调用getMapper()生成每个dao接口的代理对象 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 指定SqlSessionFactory对象的id --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 指定包名，包名是dao接口所在的包名 --&gt; &lt;!-- MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行一次getMapper方法，得到每个接口的dao对象 --&gt; &lt;!-- 创建好的dao对象放到spring的容器中,dao对象的默认名称为接口名首字母小写 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.pjh.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 声明Service对象 --&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.pjh.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类，获取sevice对象，通过service调用dao完成数据库的访问 4.4 小贴士mybatis和spring整合使用时，事务自动提交，不需要再手动commit 5 Spring的事务处理5.1 事务什么是事务： 事务是指一组sql语句的集合，集合中有多条sql语句，可能是insert，update，select，delete，我们希望这些多个sql语句都能成功或者失败，这些sql语句的执行是一致的，作为一个整体执行。 什么时候使用事务： 当操作涉及多个表，或者是多个sql语句的insert，update，delete。需要保证这些语句都是成功才能完成我的功能，或者都失败，保证操作时符合要求的；在java代码中写程序，控制事务，应该放在service类的业务方法上，因为业务方法会调用多个dao方法，执行多个语句 jdbc和mybatis访问数据库怎样处理事务： jdbc：Connection.commit(); Connection.rollback(); mybatis：SqlSession.commit(); SqlSession.rollback(); 缺陷： 不同数据库访问技术，处理事务的对象，方法不同，需要了解不同数据库访问技术使用事务的原理 掌握多种数据库中事务的处理逻辑。什么时候提交，什么时候回滚 处理事务的多种方法 总结：多种数据库访问技术，有不同的事务处理的机制，对象，方法 怎么解决不足： spring提供了一种处理事务的统一模型，能使用统一步骤、方法完成多种不同数据库访问技术的事务处理。 5.2 Spring提供处理事务的统一模型声明式事务：把事务相关的资源和内容都提供给spring，spring就能处理事务提交和回滚了，几乎不用代码。 spring处理事务的模型，使用的步骤都是固定的，把事务使用的信息提供给spring就可以了 事务内部提交，回滚事务，使用的事务管理器对象，代替你完成commit和rollback 事务管理器：是一个接口和他的众多实现类。 接口：PlatformTransactionManager，定义了事务的重要方法commit、rollback 实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。 怎么使用：你需要告诉spring，你使用的哪种数据库的访问技术，在spring的配置文件种使用&lt;bean&gt;声明对应的实现类就可以了，例如mybaits就声明DataSourceTransactionManager。 你的事务方法需要什么样的事务，说明需要事务的类型 说明方法需要的事务三个方面： 事务的隔离级别：4个值 DEFAULT：MySql默认REPEATABLE_READ READ_UNCOMMITTED：读未提交。未解决并发问题 READ_COMMITTED：读已提交，解决脏读，存在不可重复读与幻读 REPEATABLE_READ：可重复读，解决脏读、不可重复读，存在幻读 SERIALIZABLE：串行化。不存在并发问题 事务超时时间：表示一个方法最长的执行时间，如果方法执行时超过了时间，事务就回滚。 单位是秒，整数值，默认是-1（不设置超时时间） 事的传播行为：控制事务方式是不是有事务，是怎样的事务。 7种传播行为，表示你的业务方法调用时，事务在方法之间时如何使用的。此处重点掌握前三个： PROPAGATION_REQUIRED 指定的方法必须需要一个事务。如果当前存在事务，方法会自动加入到事务中（白嫖）；如果不存在事务，方法会自己开启一个新的事务并加入其中（没白嫖到被迫用自己的，屑）。事务的启动和加入由spring控制。 PROPAGATION_REQUIRES_NEW 指定的方法必须需要一个事务，且必定创建一个新事务。如果当前已经存在事务，它会将旧的事务挂起，优先执行新的事务。 PROPAGATION_SUPPORTS 指定的方法非必须需要事务。如果当前存在事务，方法会自动加入到事务中；如果不存在事务，方法会以非事务方式执行。 PROPAGATION_MANDATORY PROPAGATION_NESTED PROPAGATION_NEVER PROPAGATION_NOT_SUPPORTED 事务提交和回滚的时机： 当你的业务方法执行成功，且没有异常抛出，当方法执行完毕，spring在方法执行后提交事务。 当你的业务方法抛出运行时异常或ERROR，spring执行回滚，调用事务管理器的rollback 当你的业务方法抛出非运行时异常，主要是受查异常时，提交事务 受查异常：写代码时必须处理的异常。例如IOException，SQLException 5.3 spring框架中提供的两种事务处理方案5.3.1 适合中小项目使用的注解方案spring框架自己用aop实现给业务方法增加事务的功能，使用@Transactional注解增加事务。 @Transactional注解： 是spring框架自己的注解，放在public方法的上面，表示当前方法具有事务。可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等。 使用注解的步骤： 需要声明事务管理对象：&lt;bean id=”xx” class=”DataSourceTransactionManager”&gt; 开启事务注解驱动，告诉spring框架，我要使用注解的方式管理事务 spring使用aop机制，创建@Transactional所在类的代理对象，给方法加入事务功能 spring给业务方法加入事务： 在你的业务方法执行前，先开启事务，在业务方法结束后提交或者回滚事务吗，使用aop的环绕通知 123456789&lt;!-- 使用spring的事务处理 --&gt;&lt;!-- 1. 声明事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 指定数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- 2. 开启事务注解驱动，告诉spring使用注解管理事务，创建代理对象 --&gt;&lt;!-- transaction-manager:事务管理器对象id --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 在方法上方加入@Transactional注解 12345678910111213141516171819202122232425262728293031323334353637383940/*** rollback：表示发生指定的异常一定回滚* 处理逻辑：* 1. spring框架会首先检查方法抛出的异常是不是在rollbackfor的属性值中，如果在，不管是什么类型的* 异常，一定回滚* 2. 如果抛出异常不在rollbackfor列表中，spring会判断异常是不是RuntimeException，如果是一定* 回滚。*/@Transactional( //传播方式 propagation = Propagation.REQUIRED, //隔离级别 isolation = Isolation.DEFAULT, //是否仅读 readOnly = false, //指定异常回滚 rollbackFor = &#123; NullPointerException.class, NotEnoughException.class &#125;)//或者直接使用@Transactional，使用注解的默认值@Overridepublic void buy(Integer gid, Integer nums) &#123; Sale sale = new Sale(); sale.setGid(gid); sale.setNums(nums); saleDao.insertSale(sale); Goods goods = goodsDao.selectGoods(gid); if(goods == null) &#123; throw new NullPointerException(&quot;编号 &quot; + gid + &quot;商品不存在&quot;); &#125; else if(goods.getAmount() &lt; nums) &#123; throw new NotEnoughException(&quot;编号 &quot; + gid + &quot;商品不足&quot;); &#125; Goods buyGoods = new Goods(); buyGoods.setId(gid); buyGoods.setAmount(nums); goodsDao.updateGoods(buyGoods);&#125; 5.3.2 适合大型项目使用aspectJ框架功能在spring配置文件中声明类，方法需要的事务。这种方式业务方法和事务完全分离。 实现步骤：都是在xml配置文件中实现 加入aspectJ框架的依赖 声明事务管理器对象 声明方法需要的事务类型（配置方法的事务属性：隔离级别、传播行为、超时） 配置aop：指定哪些类需要创建代理 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 使用spring的事务处理 --&gt;&lt;!-- 1. 声明事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 指定数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- 2. 声明业务方法的事务属性 --&gt;&lt;!-- id:自定义名称，表示标签之间的配置内容的 --&gt;&lt;!-- transaction-manager:事务管理器对象id --&gt;&lt;tx:advice id=&quot;myAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- attributes：配置事务属性 --&gt; &lt;tx:attributes&gt; &lt;!-- method:给具体的方法配置事务属性，method可以有多个，分别给不同的方法设置事务属性 --&gt; &lt;!-- name：方法名称 1. 完整方法名称，不带一包和类名 2. 方法可以使用通配符，*表示任意字符 --&gt; &lt;tx:method name=&quot;buy&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; rollback-for=&quot;java.lang.NullPointerException,com.pjh.exception.NotEnoughException&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 3. 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式：表达哪些包中的类要使用事务 id：切入点表达式的名称，唯一值 expression：切入点表达式，指定哪些类要使用事务，aspectJ会创建代理对象 --&gt; &lt;aop:pointcut id=&quot;servicePt&quot; expression=&quot;execution(* *..service..*.*(..))&quot;/&gt; &lt;!-- 配置增强器 关联advice和pointcut advice-ref：通知 pointcut-ref：切入点表达式的id --&gt; &lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;servicePt&quot;/&gt;&lt;/aop:config&gt; 总结spring的学习就暂时到此为止了，那是真的难顶，下一站springMVC 6 web项目中怎么使用容器对象web项目在服务器上运行，tomcat一启动，项目一直运行，如果每次都要创建一次容器对象，是十分消耗资源的行为，因此spring容器对象存在一个即可。 我们将创建好的容器对象放到全局作用域ServletContext中。 实现： 使用监听器，当全局作用域对象被创建时，创建容器，存到ServletContext中 监听器的作用： 创建容器对象 将容器对象存到ServletContext 监听器可以自己创建，也可以使用框架提供好的ContextLoaderListener 使用步骤： 在web.xml中注册监听器 123456789101112&lt;!-- 注册监听器 --&gt;&lt;!-- 监听器被创建对象后，会读取WEB-INF中的applicationContext.xml文件 --&gt;&lt;!-- 可以使用contest-param修改文件位置 --&gt;&lt;context-param&gt; &lt;!-- 需要配置的监听器对象 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 指定文件路径 --&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 在servlet中获取容器对象 1234567WebApplicationContext context = null;//自己通过key找到全局作用域中的webApplicationContext//String key = WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE;//context = (WebApplicationContext) request.getServletContext().getAttribute(key);/context = WebApplicationContextUtils.getWebApplicationContext(getServletContext());","categories":[],"tags":[]},{"title":"","slug":"rentCar","date":"2022-01-02T09:58:01.239Z","updated":"2021-09-22T09:57:28.885Z","comments":true,"path":"2022/01/02/rentCar/","link":"","permalink":"http://example.com/2022/01/02/rentCar/","excerpt":"","text":"品牌-载货量 车牌号 日租金（元） 折扣 重汽，30吨 京A100Z2 1000 days&gt;=7 9折 重汽，49吨 京A100Z3 2100 days&gt;=30 8折 东风，30吨 京A101E4 1500 days&gt;=60 7折 东风，49吨 京A101E5 2700 days&gt;=180 6折","categories":[],"tags":[]},{"title":"","slug":"MYSQL","date":"2022-01-02T09:58:01.237Z","updated":"2021-06-06T09:47:41.913Z","comments":true,"path":"2022/01/02/MYSQL/","link":"","permalink":"http://example.com/2022/01/02/MYSQL/","excerpt":"","text":"MYSQL库（database），表（table） [TOC] SQL语句：DQL（数据查询）：select 简单查询： 12select 字段名1,字段名2... from 表名;select 字段名 as 新字段名 from 表名; ​ select (字段名1),(字段名2)… from (table_name) ; ps: 字段可以参与数学运算 ​ 在字段号后加上 as (rename) 可以给查询结果的列重命名。命名可以为中文。 ​ 标准sql语句要求字符串用单引号括起来，尽管mysql支持双引号。 ​ 将字段名写作 “*” 代表查询该表所有数据。效率较低。 条件查询： 123456select 字段,字段...from 表名where 条件 ; ​ 条件语句包括： ​ =, ＜, &gt;, &lt;=, &gt;=, != ,&lt;&gt; (不等于), ​ between … and … (左闭右开区间), ​ is (not) NULL (NULL不等于0.0), ​ or(或), and(并), ​ (not) in(或): in (条件一,条件二), ​ like (模糊查询) ： ​ %表示任意多个字符，_表示任意一个字符 ​ like ‘%字符%’ ; ​ like ‘_字符%’ 表示查找第二位是字符的数据； ​ 要查询带有_或%的字符，写成\\_或\\% 排序： 1234567select 字段,字段...from 表名order by 条件; ​ asc升序，desc降序，默认升序 ​ 用逗号隔开排序条件，表示在前面字段无法排序，才启动后面的字段排序 ​ 可以用数字代替字段，表示指定列 ​ 条件和排序可以组合，先执行条件，再执行排序，语句顺序也同上 分组函数： ​ count ()计数 ​ sum ()求和 ​ max ()最大值 ​ min ()最小值 ​ avg ()平均数 ​ 对某一组数据处理，又称多行处理函数：多行处理，一行输出。 ​ 分组函数自动忽略NULL ​ 单行处理函数：ifnull(字段，替换值)如果数据为null则替换 ​ 只要有NULL参与的计算，结果都为NULL ​ 分组函数不能直接用于where子句中 ​ count(*)表示统计表中的所有不为NULL的数据总数量 分组查询： ​ group by 和 having ​ group by：按照某个字段或者某些字段进行分组。 ​ having：是对分组后的数据进行再次过滤。 1234567select 字段，字段... 分组函数（）from 表group by 字段，字段; ​ 分组函数一般和group by组合使用， ​ 并且任何一个分组函数都在group by执行后才会执行。 ​ group by在where之后执行 ​ 如果没有group by整张表自成一组。 == select from group by * ; ​ 没有被group by分组的字段，查询出的结果没有意义。 ​ 因此，select后面只能够被分组的字段和分组函数。 12345678select 字段，字段...from 表group by 字段，字段...having 条件 ; ​ where搞不定的情况再用having。 ​ 因为先过滤再分组效率较高。 ​ where 可以和 having 一起用。 查询去重 12345selectdistinct 字段，字段...from 表 ​ distinct 只能出现在所有字段的最前面。 ​ distinct 会对所有字段的重复去重 连接查询（跨表查询） 内连接： 表之间是平等的，只有都能匹配上的数据才会查询出来 等值连接（条件是等值关系） 非等值连接（条件是非等值关系） 自连接（在同一张表） 1234567891011121314151617SQL92select 字段，字段...from 表，表...where 条件SQL99select 字段，字段...from 表(inner) join 表on 条件 外连接： 分为主表和副表，主要查询主表，顺带查询副表，主表有的数据，附表没有，则会用null代替(主表数据无条件查出来) 左（外）连接：左边是主表 右（外）连接：右边是主表 123456789101112131415161718左连接select 字段，字段...from 表(主表)left (outer) join 表on 条件 ;右连接select 字段，字段...from 表right (outer) join 表(主表)on 条件 ; 全连接： 注意： 笛卡尔乘积现象：当两张表连接查询时，没有任何条件限制下，查询结果条数是两张表的数据条数的乘积 避免了笛卡尔现象也不会减少查询次数，只会影响查询结果的显示 在from子句中，在表名后输入一个字符串表示用该字符串代表 表，俗称取别名。 1... from emp e ... 给表取别名是个好习惯，通过表名（表的别名）和字段用’ . ‘连接，来指定那张表中的字段，避免重名造成的困扰。 查询多个表时，就多写几个join on 嵌套查询（子查询） select语句中可嵌套的位置在： 123456select (select)from (select)where (select) union（可以将查询结果集相加） 123select ...unionselect ... 合并后的列名为第一句的字段名 第一句的查询列数和第二句的必须一样 limit limit是mysql独有的 limit取结果集中的部分数据 1234567select 字段，字段...from 表名limit startIndex length startIndex表示起始位置，从0开始，0表示第一条数据。 length表示取几个 startIndex省略时，默认从0开始往后取 查询分页： 123int pageNo = n;int pageSize = 10;limit (pageNo - 1) * pageSize , pageSize ; 执行顺序 12345678910111213select 5from 1where 2group by 3having 4order by 6limit 7 DML（数据操作）：insert delete update insert插入数据 12insert into 表名(字段1,字段2,字段3,...) values(值1,值2,值3,...) ;insert into 表名 select语句 ;//将查询结果插入到表中 delete删除数据 1delete from 表 where 条件 ; 不加where条件表示删除所有。 update修改数据 1update 表名 set 字段1=值1 , 字段2=值2 , ... where 条件 ; ​ 不加where条件表示修改所有。 DDL（数据定义）：create drop alter 创建表 123456create table 表名 ( 字段1 数据类型 (default 数据), 字段2 数据类型 (default 数据), 字段3 数据类型 (default 数据), ...); 复制表 1create table 表名 as select语句 ; 将查询结果当作表创建出来 删除表 1drop table if exists 表名; 删除大表 1truncate table 表名 ; 直接截断，不可回滚。永久丢失。 常见数据类型： 1234567891011121314151617int 整数型bigint 长整型float 浮点型char 定长字符串varchar 可变长字符串date 日期类型BLOB 二进制大对象（储存图片、视频等流媒体信息）Binary Large OBjectCLOB 字符大对象（存放大文本）Character Large OBject... ​ char会给字符串分配固定空间，varchar会在不超过上限的情况下动态分配空间 ​ 当某个字段的数据长度不发生变化时，是定长的，可以使用char ​ 反之不固定时，使用varchar 约束 在创建表时可以对表的字段添加相应的约束，添加约束的目的在于保证表中数据的合法性、有效性、完整性。 常见约束： 非空约束（not null）：约束字段不能为NULL ​ 唯一约束（unique）：约束字段不能重复，但可以为NULL ​ 主键约束（primary key）：约束字段既不能为NULL也不能重复（简称PK） ​ 作用：主键值是这行记录在这张表中的唯一标识 ​ 分类：单一主键（推荐）和复合主键（多个字段联合起来添加一个主键，不推荐） ​ 自然主键（推荐）和业务主键（主键值与系统业务挂钩，最好不要） ​ 一张表只能有一个主键 ​ 在主键约束后加上 auto_increment，主键字段会自动维护一个自增的数字，从1开始， 依次加1。 ​ 外键约束（foreign key）：添加外键约束的值必须来自于某个字段（简称FK） 1foreign key （字段）references 表（字段）; ​ 此时，外键的来源称为父表，当前表称为子表。 ​ 外键引用的的值必须具有唯一性 ​ 在创建，删除，添加时，必须严格按照父子关系，顺序操作。 ​ 检查约束（check）：oracle中有，mysql没有，且暂不支持。 约束可以在创建时在数据类型后添加（列级约束） 也可以在最后用逗号和前面子句隔开，使用约束词(字段，字段)。（表级约束）除了not null 如： 123456create table 表( 字段1, 字段2, ... , 约束(字段1,字段2...)) TCL（事务操作）：commit rollback 事务（Transactions） 一个事务是一个完整的业务逻辑单元，不可再分。 要想保证两条或以上的DML语句同时成功或失败，那么需要使用数据库的“事务机制”。 事务的存在是为了保证数据的完整性，安全性。 mysql事务默认情况下自动提交，关闭自动提交，使用语句 start transaction；启动事务，使用commit提交，使用rollback回滚 四大特性： A 原子性：最小工作单元，不可再分。 C 一致性：事务必须保证多条DML语句同时成功或同时失败。 I 隔离性：事务A和事务B之间具有隔离。 D 持久性：最终数据必须持久化到硬盘文件中，事务才算成功结束 关于事务的隔离性：事务存在隔离级别，理论上包括四个： 第一级别：读未提交（read uncommitted） 对方事务还未提交，我方事务可以读取对方未提交的数据 存在脏读（Dirty Read）现象：表示读到脏数据 第二级别：读已提交（read committed） 对方事务提交后的数据我方可以读取 解决了脏读现象 出现问题：不可重复读（表示在我方事务未结束时，多次读取对方提交的数据得到的不一样） 第三级别：可重复读（repeatable read） 解决不可重复读的问题 出现问题：读取到的数据是幻想 第四级别：序列化读/串行化读（serializable） 解决了所有问题 效率低，需要排队 原理：启动事务机制（开始） ​ DML语句1； ​ DML语句2； ​ DML语句3； ​ … ​ （只是记录到操作历史记录中，并不会真实修改数据） ​ 提交事务或回滚事务（结束）（此时根据操作修改或取消修改，并消除历史操作） commit 提交 rollback 回滚 savepoint 储存状态 savepoint name；储存一个点 rollback name；回滚到点 DCL（权限管理）： 新建用户： 1CREATE USER username IDENTIFIED BY &#x27;password&#x27;; 授权 1grant 权限 on databasename.tablename to &#x27;username&#x27; @loginip identified by &#x27;password&#x27; with grant option; 撤销权限 1revoke 权限 on databasename(.tablename) from username; DBA（导入导出）： 导出数据库中的数据: 在windows的dos窗口中执行（导出库） ​ mysqlump databasename &gt;D:\\databasename.sql -u -p 在windows的dos窗口中执行（导出表） ​ mysqlump databasename tablename &gt;D:\\databasename.sql -u -p 导入数据 在mysql中 ​ create database databasename； ​ use databasename； ​ source D:\\databasename.sql 注意： 任何一条语句以”;”结尾。 sql语句不区分大小写。数据区分大小写。 存储引擎​ 表的存储方式，每一种存储引擎有不同的存储方式，各有其优缺点 Engine Support Comment Transactions XA Savepoints InnoDB DEFAULT Supports transactions, row-level locking, and foreign keys YES YES YES MRG_MYISAM YES Collection of identical MyISAM tables NO NO NO MEMORY YES Hash based, stored in memory, useful for temporary tables NO NO NO BLACKHOLE YES /dev/null storage engine (anything you write to it disappears) NO NO NO MyISAM YES MyISAM storage engine NO NO NO CSV YES CSV storage engine NO NO NO ARCHIVE YES Archive storage engine NO NO NO PERFORMANCE_SCHEMA YES Performance Schema NO NO NO FEDERATED NO Federated MySQL storage engine NO NO NO MyISAM 是MYSQL最常用的，具有以下特征： 使用三个文件表示每个表： 格式文件（frm） 数据文件（MYD） 索引文件（MYI） 灵活的AUTO_INCREMENT字段处理 可被转换为压缩、只读表来节省空间 不支持事务 InnoDB 是MYSQL默认的 支持事务、行级锁、外键等，比较安全 主要特征： 表结构储存在（.frm）文件中 表数据存储在tablespace中（逻辑概念），无法被压缩，无法转换为只读 提供崩溃后自动恢复机制 支持级联删除和级联更新（有联系的数据） MEMORY 缺点：不支持事务，数据容易丢失。因为所有数据和索引储存在内存中。 优点：查询速度最快 索引 建立索引可以缩小扫描范围，从而实现高效查询。 索引不被推荐在需要频繁修改的数据表中，一旦数据改动，索引就需要重新排序、进行维护。 添加索引是给某个字段或者某些字段添加 什么时候考虑给字段添加索引？ 数据量庞大（根据需求和环境） 该字段很少的DML操作 该字段经常出现在where子句中 主键和具有unique约束的字段会自动添加索引 ​ 根据主键查询效率高。 添加/删除索引： 12create index name on 表名(字段名);drop index name; 底层索引 索引底层使用数据结构：B + Tree 生成的索引存在硬盘文件或内存中（根据储存引擎），并且会携带每个数据的物理地址 索引会自动排序，之后对数据（物理地址）分区，存进B+Tree中 对有索引的数据列查询，等于直接查询物理地址，通过地址定位表中数据。 索引分类： 单一索引：给单一字段添加索引 复合索引：给多个字段联合起来添加一个索引 主键索引：主键上自动添加索引 唯一索引：有unique约束的字段会自动添加索引 … 索引什么时候失效？ 模糊查询时，第一个通配符使用的是%，这时候索引失效。 … 视图（view） 站在不同的角度去看数据（同一张表的数据，通过不同的角度去看待）。 创建/删除视图 12create view name as select语句;drop view name; 对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据，不是直接操作的原表） 可以对视图进行CRUD操作 面向视图操作 123select 字段名 from name;update name set 字段1=值1 , 字段2=值2 , ... where 条件;delete from name where 条件; 视图的作用 视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，只对视图对象进行CRUD。 MYSQL语句 show databases ；展示数据库 show tables ；展示当前数据库的表 show tables from (database_name) ; 查看其他库中的表 show create table (table_name) ; 查看创建表的SQL语句 use (database_name) ；使用指定数据库 create database (database_name) ; 创建数据库 source (文件目录) ；导入sql脚本 desc (table_name) ; 展示数据库结构 select database() ; 查看当前数据库 select version() ; 查看mysql版本号 set global transaction isolation level （）；设置全局隔离级别 explain + SQL语句；查询该语句的执行计划 \\c 结束一条语句 exit 退出 数据库设计三范式设计表的依据。依照这个三范式设计的表不会出现数据冗余。 三范式： 第一范式：任何一张表都应该有主键，并且每个字段原子性不可再分。 第二范式：建立在第一范式的基础上，所以非主键字段完全依赖于主键，不要产生部分依赖。 ​ 多对多，三张表，关系表两外键 第三范式：建立在第二范式的基础上，所有非主键字段直接依赖主键，不要产生传递依赖。 ​ 一对多，两张表，多得表加外键 提醒：在实际开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。 一对一怎么设计？ 拆分大表为小表，表之间得关系设计有两种方案： 主键共享 外键唯一","categories":[],"tags":[]},{"title":"","slug":"MyBatis","date":"2022-01-02T09:58:01.234Z","updated":"2021-09-19T12:21:24.207Z","comments":true,"path":"2022/01/02/MyBatis/","link":"","permalink":"http://example.com/2022/01/02/MyBatis/","excerpt":"","text":"MyBatis 框架1 总体概述1.1 软件开发常用结构1.1.1 三层架构三层架构包括的三层： ​ 界面层、业务逻辑层、数据访问层 三层的职责： 界面层：接受用户数据，显示请求的处理结果。（jsp，html，servlet） 业务逻辑层：接受界面层传递过来的数据，检查数据，计算业务逻辑，调用数据访问层获取数据。（service） 数据访问层：与数据库打交道。实现对数据的增删改查。（dao） 三层对应的包： 界面层：controller （servlet） 业务逻辑层：service （service类） 数据访问层：dao （dao类） 三层中类的交互： ​ 用户使用界面层——》业务逻辑层——》数据访问层——》数据库 三层对应的处理框架： ​ 界面层——servlet——springmvc ​ 业务逻辑层——service类——spring ​ 数据访问层——dao类——mybatis 1.2 框架（Framework）1.2.1 框架是一个模板 框架中定义好了一些功能，这些功能时可用的。 可以加入项目中自己的功能，这些功能可以利用框架中写好的功能。 框架是一个半成品软件，定义好了一些基础功能，需要加入自己的功能来完善。基础功能是可重复使用的，可升级的。 1.2.2 框架特点 框架是有局限的，不能干所有事情 框架是针对某一个领域有效。 框架是一个软件 1.3 JDBC的缺陷使用JDBC的缺陷： 代码比较多，开发效率低 需要关注Connection，Statement，ResultSet对象创建和销毁 对Result查询的结果，需要自己封装为list 重复的代码比较多 业务代码和数据库的操作混在一起 总之，我们需要一个新的工具代替JDBC，以弥补JDBC的缺陷。那就是我们今天所学的MyBatis 1.4 MyBatis框架是什么1.4.1 MyBatis的背景MyBatis本是 apache 的一个开源项目 iBatis, 2010年这个项目由 apache software foundation迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects (DAOs) 1.4.2 MyBatismybatis是MyBatis SQL Mapper Framework for Java （sql映射框架） sql mapper：sql映射 可以把数据库表中的一行数据映射为一个java对象 一行数据可以看作是一个java对象，操作这个对象，就相当于操作表中的数据 Data Access Objects （DAOs）：数据访问 对数据库执行增删改查 1.4.3 MyBatis提供了哪些功能 提供了创建Connection，Statement，ResultSet的能力，不用开发人员创建这些对象 提供了执行sql语句的能力，不用你执行sql 提供了循环sql，把sql的结果转为java对象List集合的能力 提供了关闭资源的能力，不用你关闭connection，statement，resulset 开发人员需要做的是：提供sql语句（工作量大幅减少了） 流程：开发人员提供sql语句——》mybatis处理sql——》开发人员得到List集合或者java对象 1.4.4 总结mybatis是一个sql映射框架，提供数据库的操作能力。增强的JDBC，使用mybatis让开发人员集中精神写sql就可以了，不必关心Connection等的创建销毁，sql的执行。 2 快速入门2.1 入门案例2.1.1 使用MyBatis的准备下载mybatis,此处我们使用的是3.5.1版本 https://github.com/mybatis/mybatis-3/releases 2.1.2 创建一张表123456789101112DROP TABLE IF EXISTS student;CREATE TABLE student ( id int(11) NOT NULL, name varchar(255) DEFAULT NULL, email varchar(255) DEFAULT NULL, age int(11) DEFAULT NULL, PRIMARY KEY(id))ENGINE=innoDB DEFAULT CHARSET=utf8;INSERT INTO student VALUES(1001,&quot;李四&quot;,&quot;lisi@163.com&quot;,20);INSERT INTO student VALUES(1002,&quot;张三&quot;,&quot;zhangsan@163.com&quot;,28); 创建好的表： 2.1.3 创建项目（略）2.1.4 编辑POM文件增加MYSQL-connector和MyBatis依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt;&lt;/dependency&gt; 2.1.5 创建Student实体类和对应的Dao类（略）2.1.6 创建MyBatis使用的配置文件——sql映射文件sql映射文件： 一个xml文件 一般一个表对应一个sql映射表 应当存放在dao接口所在的目录 文件名称和接口保持一致 其作用在于：写与接口中方法对应的sql语句 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;!-- id:你要执行的sql语法的唯一标识，mybatis会使用这个id的值来找到要执行的sql语句 可以自定义，但是要求你使用接口中的方法名称 resultType:表示结果类型，是sql语句执行后得到的ResultSet 遍历这个Res得到的java对象的类型 值写的是类型的全限定名称 --&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;!-- 以上为官方文档的示例代码 --&gt;&lt;!-- sql映射文件：写sql语句的，mybatis会执行这些sql 1.指定约束文件 &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; mybatis-3-mapper.dtd 约束文件的作用，拓展名是dtd。 2.约束文件的作用：限制，检查在当前文件中出现的标签，属性必须符合mybatis要求 3.mapper 当前文件的根标签，必需的。 namespace 命名空间，唯一值，可以是自定义的字符串。 要求你使用dao接口的全限定名称。 4.在当前文件中，可以使用特定标签，表示数据库的特定操作。 &lt;select&gt; 查询，在标签内写select语句 &lt;update&gt; 更新，在标签内写update语句 ... 基本与sql语句相同--&gt; 2.1.7 创建主配置文件文件名可以自定义，文件类型为xml，文件应当被放置在resources的根目录下 其目的在于： 连接数据库 指定mapper文件的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 环境配置：数据库的连接信息 default:必须和某个environment的id值一样 告诉mybatis使用哪个数据库的连接信息。就是访问哪个数据库 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment:一个数据库的配置，环境 id:一个唯一值，自定义，表示环境的名称 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- transactionManager:mybatis的事务类型 type:JDBC(表示使用jdbc中的connection对象的commit，rollback做事务处理) MANAGED:把mybatis的事务处理委托给其他容器(一个服务器软件，一个框架spring) --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:表示数据源，连接数据库 数据源:表示连接connection对象的; 在java中的规范中，实现了javax.sql.DataSource的都是数据源。 type:表示数据源类型 pooled:表示使用连接池,mybatis会创建pooledDataSource类 unpooled:不使用连接池，在每次执行sql语句，先创建连接，执行sql，再关闭连接 mybatis会创建一个unpooledDataSource类 JNDI:java命名和目录服务（windows注册表） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- driver:数据库的驱动类型名 url:连接数据库的url字符串 username:访问数据库的用户名 password:访问数据库的密码 name是固定的不能修改 --&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- sql mapper(sql映射文件)的位置 --&gt; &lt;mappers&gt; &lt;!-- 一个mapper标签指定一个文件的位置 文件位置：要包括target/classes之后的文件路径 --&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/example/OrderMapper.xml&quot;/&gt; &lt;!-- 指定多个mapper文件 可以一条一条mapper，如上面 也可以使用package，一次性添加多条mapper --&gt; &lt;!-- name:xml文件所在得包的名称，这个包中所有xml文件一次加载进mybatis 使用要求： mapper文件名称需要和接口名称一样，区分大小写 mapper文件和dao接口需要在同一目录 --&gt; &lt;package name=&quot;com.mybatis.example&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt;&lt;!-- mybatis的主配置文件：主要定义了数据库的配置信息，sql映射文件的位置 1.约束文件 &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; mybatis-3-config.dtd是约束文件的名称 2.&lt;configuration&gt;根标签。--&gt; 为了能在maven编译后读取到资源文件（sql映射文件）需要加入一个插件 12345678910&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在目录--&gt; &lt;includes&gt;&lt;!--包括目录下的.properties,.xml文件都会扫描到--&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 2.1.8 使用mybatis进行数据库的查询使用mybatis的对象SqlSession，通过它的方法执行sql语句 1234567891011121314151617181920212223242526public class MyApp &#123; public static void main(String[] args) throws IOException &#123; //访问mybatis读取student数据 //1.定义mybatis主配置文件的名称，从根目录开始（target/classes） String config = &quot;mybatis.xml&quot;; //2.读取这个文件 InputStream in = Resources.getResourceAsStream(config); //3.创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //4.创建SqlSessionFactory对象 SqlSessionFactory factory = builder.build(in); //5.**取SqlSession对象，从SqlSessionFactory中获取SqlSession** SqlSession sqlSession = factory.openSession(); //6.拼接sql语句标识。sql映射文件中的namespace+&quot;.&quot;+标签的id值 String sqlId = &quot;com.pjh.dao.StudentDao&quot;+&quot;.&quot;+&quot;findAll&quot;; //7.执行sql语句，通过sqlId找到语句 List&lt;Student&gt; studentList = sqlSession.selectList(sqlId); //8.输出结果 for(Student stu:studentList) &#123; System.out.println(&quot;查询的学生=&quot;+stu); &#125; //9.关闭SqlSession对象 sqlSession.close(); &#125;&#125; 得到结果： 12查询的学生=Student&#123;id=1001, name=&#x27;李四&#x27;, email=&#x27;lisi@163.com&#x27;, age=20&#125;查询的学生=Student&#123;id=1002, name=&#x27;张三&#x27;, email=&#x27;zhangsan@163.com&#x27;, age=28&#125; 2.1.9 使用MyBatis进行增删改mybatis默认不会自动提交事务，需要手动进行提交 具体： 12int num = sqlSession.insert(sqlId,student);sqlSession.commit();//**** 2.1.10 sql映射文件中sql语句的写法sql语句中用#{字段名}来读取类的属性，并填入sql语句中 例如： 1insert into student values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;) 2.2 主要类的介绍 Resources： 1InputStream in = Resources.getResourceAsStream(config); mybatis中的一个，负责读取主配置文件的类 SqlSessionFactoryBuilder： 12SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(in); 负责创建SqlSessionFactory对象 SqlSessionFactory：需要使用大量资源，整个程序只需创建一次就够了；它是一个接口，实现类为DefaultSqlFactory。 作用：获取SqlSession对象 1SqlSession sqlSession = factory.openSession(); openSession()方法说明： openSession()：无参，获取非自动提交事务的SqlSession对象 openSession(boolean)：为true时，获取自动提交事务的SqlSession；为false，获取非自动提交事务的SqlSession SqlSession：接口，实现类为DefaultSqlSession 定义了操作数据的方法，例如selectOne，selectList，insert，delete等等 使用要求：SqlSession对象不是线程安全的，需要在方法内部使用，在执行sql语句之前，使用openSession（）获取SqlSession对象，在执行完sql语句后，需要关闭它，执行SqlSession.close（），这样能保证它的使用是线程完全的 2.3 Mybatis工具类以上入门案例使用的调用dao的方法十分繁琐，且有大量的代码复用问题，因此可以引入一个mybatis工具类，以减轻开发的繁琐程度。 12345678910111213141516171819202122232425262728293031323334package com.pjh.uitls;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtils &#123; private static SqlSessionFactory factory = null; static &#123; String config = &quot;mybatis.xml&quot;; try &#123; InputStream in = Resources.getResourceAsStream(config); factory = new SqlSessionFactoryBuilder().build(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //主要提供的方法，返回一个sqlSession public static SqlSession getSqlSession() &#123; SqlSession sqlSession = null; if(factory != null) &#123; sqlSession = factory.openSession(); &#125; return sqlSession; &#125;&#125; 再创建这个工具类后，2.1.8中的代码可以改写为 1234567891011121314151617181920212223242526package com.pjh;import com.pjh.domain.Student;import com.pjh.uitls.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import java.io.IOException;import java.util.List;public class MyApp2 &#123; public static void main(String[] args) throws IOException &#123; SqlSession sqlSession = MyBatisUtils.getSqlSession(); String sqlId = &quot;com.pjh.dao.StudentDao.findAll&quot;; List&lt;Student&gt; studentList = sqlSession.selectList(sqlId); for(Student stu:studentList) &#123; System.out.println(&quot;查询的学生=&quot;+stu); &#125; sqlSession.close(); &#125;&#125; 3 深入理解3.1 Mybatis动态代理在引入了工具类后尽管稍微减少了开发的难度，但是仍然存在部分代码相似度比较高的情况，可以进一步优化，由此引出Mybatis的动态代理。 简要原理如下： mybatis根据dao方法的调用，获取执行sql语句的信息。 mybatis根据你的dao接口，创建出一个dao接口的实现类，并创建这个类的对象。 完成sqlSession调用方法，访问数据库。 再次对2.1.8进行修改： 12345678910111213141516171819202122232425package com.pjh;import com.pjh.dao.StudentDao;import com.pjh.domain.Student;import com.pjh.uitls.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import java.util.List;public class TestMyBatis &#123; /** * 使用mybatis的动态代理机制，使用SqlSession.getMapper(dao接口) * getMapper能获取dao接口对应的实现类对象 */ public static void main(String[] args) &#123; SqlSession sqlSession = MyBatisUtils.getSqlSession(); StudentDao dao = sqlSession.getMapper(StudentDao.class); //调用dao方法，执行数据库操作 List&lt;Student&gt; students = dao.findAll(); for(Student stu : students) &#123; System.out.println(&quot;学生=&quot;+stu); &#125; &#125;&#125; 使用动态代理后，程序员仅需创建Dao接口和对应的mapper文件，即可完成对数据库的操作。 3.2 传入参数从java代码中把数据传入mapper文件的sql语句中。 parameterType：写在mapper文件中的一个属性。表示dao接口中方法参数的数据类型。其值为java数据类型的全限定名称或者mybatis定义的别名。 Alias Mapped Type _byte byte _longlong long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator mapper文件中： 123456789&lt;!-- 全限定名称 --&gt;&lt;select id=&quot;selectById&quot; parameterType=&quot;java.lang.Integer&quot; resultType=&quot;com.pjh.domain.Student&quot;&gt; select * from student where id=#&#123;id&#125;&lt;/select&gt;&lt;!-- 别名 --&gt;&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;com.pjh.domain.Student&quot;&gt; select * from student where id=#&#123;id&#125;&lt;/select&gt; 但实际上parameterType可以不写，mybatis通过反射机制可以发现接口参数类型。 123&lt;select id=&quot;selectById&quot; resultType=&quot;com.pjh.domain.Student&quot;&gt; select * from student where id=#&#123;id&#125;&lt;/select&gt; 简单类型参数：mybatis把java的基本数据类型和string都叫做简单类型。 在mapper文件获取简单类型的一个参数的值，使用#{任意字符} 多个参数，使用@Param命名参数 12345//接口public List&lt;Student&gt; selectMulitParam(String name, Integer age);//使用@Param(&quot;参数名&quot;) public List&lt;Student&gt; selectMulitParam(@Param(&quot;myname&quot;) String name, @Param(&quot;myage&quot;) Integer age); mapper文件： 123&lt;select&gt; select * from student where name=#&#123;myname&#125; and age=#&#123;myage&#125;&lt;/select&gt; 多个参数，使用java对象参数 使用对象语法：#{属性名, javaType=类型名称, jdbcType=数据类型} 完整格式 ​ javaType：指java中的属性数据类型 ​ jdbcType：指数据库中的数据类型 JDBCTypes： BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY 简化的格式：#{属性值}，javaType和jdbcType的值mybatis反射可以获取，不用提供 多个参数，按参数位置传参 语法格式：#{arg0}，其中0是参数的位置，其他是固定的 多个参数，使用Map传参 定义一个map： 123Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.add(&quot;myname&quot;,&quot;张三&quot;);map.add(&quot;myage&quot;,22); Dao接口： 1public List&lt;Student&gt; select(Map&lt;String, Object&gt; map); 语法格式：#{myname}，其中大括号中写map中的key值 #与$ #：占位符，用来代替实际参数值，并使用PrepareStatement对象执行sql语句，#{}代替了sql语句中的？。这样做更加安全、迅速，建议使用。 $：字符串替换，使用的Statement对象执行，效率比ps低，且存在sql注入的问题。一般用于替换列名或者表名 3.3 Mybatis内部机制其实是JDBC略 3.4 封装MyBatis输出结果mybatis执行了sql语句，得到的java对象 3.4.1 resultType结果类型，指sql语句执行完毕后，数据转为的java对象类型，该java类型是任意的。 处理方法： mybatis执行sql语句，然后mybatis调用类的无参数构造方法，创建对象。 mybatis把ResultSet指定列值付给同名的属性。 类型： 简单类型：同3.2.2 定义自定义类型的别名 在mybatis主配置文件中定义，使用定义别名 或者使用，name是包名，这个包中的所有类，类名就是别名（类名不区分大小写） 可以在resultType中使用自定义的别名 3.4.2 查询返回Mapmybatis可以把查询结果组织成一个map并返回 注意： 列名是map的key，列值是map的value 只能返回一行记录，多余一行会报错 3.4.3 resultMap结果映射，指定列名和java对象的属性对应关系的 用途： 自定义列值赋值给哪个属性 当你的列名和属性名不一样时，一定使用resultMap 语法格式： 1234567891011121314151617181920&lt;!-- 定义resultMap id:自定义名称，表示你定义的这个resultMap type:java类型的全限定名称--&gt;&lt;resultMap id=&quot;stuMap&quot; type=&quot;com.pjh.domain.student&quot;&gt; &lt;!-- 列名和java属性将的关系 主键列，使用id标签 column:列名 property:java类型的属性名 --&gt; &lt;id column=&quot;&quot; property=&quot;&quot;/&gt; &lt;!-- 非主键列，使用result标签 --&gt; &lt;result column=&quot;&quot; property=&quot;&quot;/&gt;&lt;/resultMap&gt;&lt;!-- 在select标签中使用resultMap属性，其中写id名 --&gt;&lt;select id=&quot;selectById&quot; resultMap=&quot;stuMap&quot;&gt; select * from student where id=#&#123;id&#125;&lt;/select&gt; 注意： resultType和resultMap不要一起用 除了使用resultMap来解决列名和属性名不一致的方法，还可以通过sql语句中的as给列名取和属性名相同的别名来解决。 3.5 模糊查询like在mybatis1中有两种方法： java代码中指定like的内容（推荐） 123&lt;select id=&quot;selectByName&quot; resultType=&quot;com.pjh.domain.Student&quot;&gt; select * from student where name like #&#123;name&#125;&lt;/select&gt; 此方法需要提前准备传入的name属性，例如： String name = “%李%” 在mapper文件中拼接like的内容 123&lt;select id=&quot;selectByName&quot; resultType=&quot;com.pjh.domain.Student&quot;&gt; select * from student where name like &quot;%&quot; #&#123;name&#125; &quot;%&quot;&lt;/select&gt; 4 动态sqlsql的内容是变化的，可以根据条件获取到不同的sql语句，主要是where部分发生变化 动态sql的实现，主要使用mybatis提供的标签。 在使用动态sql时，使用java对象作为参数 4.1 &lt;if&gt;标签if标签通过判断test中的判断结果是否为true，来判断是否将if标签中的sql语句加入 123&lt;if test=&quot;判断java对象的属性值&quot;&gt; 部分sql语句&lt;/if&gt; 4.2 &lt;where&gt;标签where标签用来包含多个if的，当多个if有一个成立，where会自动增加一个where关键字，并去掉if中多余的and，or等。 12345678&lt;where&gt; &lt;if test=&quot;判断java对象的属性值&quot;&gt; 部分sql语句 &lt;/if&gt; &lt;if test=&quot;判断java对象的属性值&quot;&gt; 部分sql语句 &lt;/if&gt;&lt;/where&gt; 4.3 &lt;foreach&gt;标签循环java中的数组，list集合，主要用在sql的in语句中。 例如：学生id是1001，1002，1003的三个学生 select * from student where id in (1001,1002,1003) 12345678910&lt;foreach collection=&quot;&quot; item=&quot;&quot; open=&quot;&quot; close=&quot;&quot; separator=&quot;&quot;&gt; &lt;/foreach&gt;&lt;!-- collection:表示接口中的方法参数的类型，如果是数组使用array，如果是list集合使用list item:自定义的表示数组和集合成员的变量 open:循环开始的字符 close:循环结束的字符 separator:集合成员之间的分隔符--&gt; 4.4 代码片段能够复用一些重复语句 步骤： 先定义 1&lt;sql id=&quot;自定义名称唯一&quot;&gt;sql语句，表名，字段等&lt;/sql&gt; 再使用 1&lt;include refid=&quot;id的值&quot;/&gt; 5 MyBatis配置文件5.1 主配置文件，见2.1.7settings：略 5.2 属性配置文件把数据库连接信息放到一个单独的文件中。和mybatis主配置文件分开 便于修改，保存，处理多个数据库的信息。 步骤： 在resources目录中定义一个属性配置文件，xxxx.properties；在属性配置文件中，定义数据，格式是key=value。 key：一般使用’.’做多级目录的。例如jdbc.mysql.driver,jdbc.driver 在mybatis的主配置文件，使用&lt;properties&gt;指定文件位置 在需要使用值的地方，${key} 6 拓展——PageHelperPageHelper可以便捷的帮你实现数据分页的功能，现已支持包括oricle，mysql在内的多达13种数据库。 安装步骤： 在pom中添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt;&lt;/dependency&gt; 记得加载一下pom 在mybatis主配置文件中的&lt;environments&gt;之间添加插件 123&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;/&gt;&lt;/plugins&gt; 在使用时调用PageHelper的静态方法startPage，会自动为你的sql语句加上limit 12345678910111213public void testSelectAll() &#123; SqlSession sqlSession = MyBatisUtils.getSqlSession(); StudentDao dao = sqlSession.getMapper(StudentDao.class); //加入PageHelper的方法，分页 //pageNum表示：第几页P //pageSize：一页中有多少数据 PageHelper.startPage(1,2); List&lt;Student&gt; studentList = dao.selectAll(); for(Student stu : studentList) &#123; System.out.println(stu); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Maven","date":"2022-01-02T09:58:01.231Z","updated":"2021-08-31T08:33:42.650Z","comments":true,"path":"2022/01/02/Maven/","link":"","permalink":"http://example.com/2022/01/02/Maven/","excerpt":"","text":"Maven学习之前你应该了解并且需要准备的软件开发中的阶段需求分析：分析项目具体需要完成的功能，有什么要求，具体怎么实现 设计阶段：根据分析结果，涉及项目的使用什么技术，解决难点 开发阶段：编码实现功能，编译代码，自我测试 测试阶段：专业测试人员，测试整个项目的功能是否符合设计要求，出一个测试报告 项目打包，发布阶段：给用户安装项目 Maven能做什么 项目的自动构建，帮助开发人员做项目代码的编译，测试，打包，安装，部署等工作 管理依赖：管理项目中使用的各种jar包 依赖：项目中需要使用的其他资源，常见的是jar。比如项目要使用的mysql驱动，我们就说项目依赖mysql驱动 没有Maven参与的依赖管理需要从网络单独下载某一个jar； 需要选择正确的版本； 手工处理jar文件之间的依赖； 什么是Maven [ˈmeɪvn]Maven是apache基金会的开源项目，使用java语言开发。 Maven是项目的自动化工具。管理项目的依赖 Maven中的概念 POM 约定的目录结构 坐标 依赖管理 仓库管理 生命周期 插件与目标 继承 聚合 Maven工具的获取与安装地址：http://maven.apache.org/ 从中下载。本笔记使用的3.3.9版本 安装： 确定JAVA_HOME指定jdk安装目录。 解压缩apache-maven-3.3.9-bin.zip，到一个目录下，该目录路径不要有中文和空格 把maven安装目录下的bin路径添加到path中 测试maven的安装。在命令行执行mvn -v 1234567C:\\Users\\yueyinghaibao&gt;mvn -vApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)Maven home: D:\\apache-maven-3.3.9\\bin\\..Java version: 1.8.0_271, vendor: Oracle CorporationJava home: C:\\Program Files (x86)\\Java\\jre1.8.0_271Default locale: zh_CN, platform encoding: GBKOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;x86&quot;, family: &quot;dos&quot; Maven的使用方式 maven可以独立使用：创建项目，编译代码，测试程序，打包，部署等等 maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等 Maven的核心概念约定的目录结构maven项目使用的大多数人遵循的目录结构。叫做约定的目录结构 123456789project文件夹 \\src \\main //叫做主程序目录（完成项目功能的代码和配置文件） \\java //源代码（包和相关的类定义） \\resources //配置文件 \\test //放置测试程序代码（开发人员自己写的测试代码） \\java //测试代码的（junit） \\resources //测试程序需要的配置文件 \\pom.xml //maven的配置文件，核心文件 POM文件即Project Object Model项目对象模型。Maven把一个项目的结构和内容抽象为一个模型，在xml文件中进行声明，以方便进行构建和描述 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- project是根标签，后面是约束文件 --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- pom模型的版本，就是4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 坐标 --&gt; &lt;groupId&gt;com.pjh&lt;/groupId&gt; &lt;artifactId&gt;01_maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 坐标坐标组成：groupid，artifactid，version。 作用：确定资源，是资源的唯一标识。在maven中，每个资源都是坐标，坐标值是唯一的。简称gav 12345678910111213&lt;!-- 坐标 --&gt;&lt;!-- groupId:组织名称，代号。公司，团体或单位的标识，这个值常使用公司的域名的倒写 artifactId:项目名称，如果groupId中有项目，此时的值就是子项目名。项目名称唯一 version:项目版本号，使用数字。三位组成：例如 主版本号.次版本号.小版本号 后面可能携带-SNAPSHOT代表快照，表示不是稳定版本 packaging:表示项目打包类型，由jar，war，ear，pom等等，默认为jar--&gt;&lt;groupId&gt;com.pjh&lt;/groupId&gt;&lt;artifactId&gt;01_maven&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 项目使用gav： 每个项目都需要有一个自己的gav 管理依赖时，需要使用其他的jar，也需要用gav作为标识 搜索依赖的gav： https://mvnrepository.com/ Maven仓库，可以在其中搜索所需依赖的gav 依赖 dependency项目中需要使用的其他资源，常见的是jar。 使用Maven表示依赖，管理依赖。需要在pom.xml文件中，使用dependencies和dependency，还有gav完成依赖的说明 格式： 12345678910111213141516&lt;!----&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; maven使用gav作为标识，从互联网下载依赖的jar。下载到你的本机上。由maven管理项目使用这些jar 仓库仓库是存放东西的，maven的仓库存放的是： maven工具自己的jar包 其他第三方的jar 自己写的程序，可以打包为jar存放在仓库 仓库分类： 本地仓库（本机仓库）：位于自己的计算机，他是磁盘中的某个目录 默认路径：在你C盘的users\\用户名\\.m2\\repository目录下 修改本地仓库的位置：修改maven配置文件（maven安装路径\\conf\\setting.xml） 步骤： 创建一个目录作为仓库使用，目录不要由中文和空格 修改setting文件，在文件内添加 1&lt;localRepository&gt;D:/repository&lt;/localRepository&gt; &lt;!--自定义目录--&gt; 私服：在局域网中使用，私服就是自己的仓库服务器。在公司内部使用 中央仓库 Maven生命周期，插件和命令maven生命周期：项目构建的各个阶段。包括清理，编译，测试，报告，打包，安装，部署 插件：要完成构建项目的各个阶段，要使用maven的命令，执行命令的功能是通过插件完成的。插件就是jar，一些类。 命令：执行maven功能是由命令发出。比如mvn compile、 单元测试（junit）junit是一个单元测试的工具，去测试方法是否完成了要求。开发人员自测 使用： 加入junit的依赖 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在src/test/java目录创建测试类文件，写测试代码 单元测试使用建议： 测试类定义，名称一般是Test+要测试的类名称 测试类包名和要测试的类包名一样 在类中定义方法，要测试代码 方法定义：public方法，没有返回值，方法名称自定义，方法没有参数 在测试类中的方法，可以单独执行，测试类也可以单独执行 在测试方法上面要加上@Test 命令 mvn clean：清理命令，作用是删除以前生成的数据，删除target目录 插件：maven-clean-plugin mvn compile：编译命令，执行的代码编译，把src/main/java目录中的java代码编译为class文件，同时把class文件拷贝到target/classes目录中。这个目录是存放类文件的根目录 插件：maven-compile-plugin（编译文件） ​ maven-resources-plugin（拷贝文件） mvn test-compile：编译命令，编译src/test/java目录中的源文件，把生成的class拷贝到target/test-classes目录。同时把src/test/resources拷贝到test-classes目录 插件：maven-compile-plugin（编译文件） ​ maven-resources-plugin（拷贝文件） mvn test：测试命令，作用执行test-classes目录的程序，是否满足要求 mvn package：打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件，默认压缩文件是jar类型的，web应用是war类型，拓展名是.jar,.war 插件：maven-jar-plugin 打包的文件包含的是src/main目录下的所有的生成的class和配置文件和test无关。 生成的文件名称是你之前在pow.xml设置的gav，格式：artifactId-version.packaging 例如：01_maven-1.0-SNAPSHOT.jar mvn install：把生成的打包文件，安装到仓库中 插件：maven-install-plugin 仓库的jar文件路径： 12345678910&lt;groupId&gt;com.pjh&lt;/groupId&gt;&lt;artifactId&gt;01_maven&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;!--groupId中的值，如果有“.”前和后都是独立的文件夹。com\\pjhartifactId，独立的文件夹version，独立文件夹--&gt; mvn deploy：部署 自定义配置插件1234567891011121314151617&lt;!--设置构建项目相关的内容--&gt;&lt;build&gt; &lt;!--设置插件相关内容--&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!--指定编译代码的jdk版本--&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!--指定运行代码的jdk版本--&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Maven和idea的集成idea中继承mavenidea中有一个自带的maven。我们要让idea使用自己安装的maven。 VM Oprions：-DarcheTypeCatalog=internal idea中创建maven项目java项目： 创建普通java项目，选择的模板 设置gav坐标 Next–》Finish Web项目： 第一步选择模板改为 idea中使用maven插件 idea导入maven项目 依赖管理依赖范围：使用scope表示依赖范围。表示这个依赖在项目构建的哪个阶段起作用 scope： compile：默认，参与构建项目的所有阶段 test：测试，在测试阶段时使用，比如junit provided：提供者。项目在部署到服务器时，不需要提供这个依赖的jar，而是服务器提供依赖。常见如servlet和jsp 只有compile会一起打包 常用设置properties里的设置 12345678910&lt;properties&gt; &lt;!-- 项目构建使用的编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 源码编译jdk版本 --&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;!-- 运行代码jdk版本 --&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- 生成报告的编码 --&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt; 定义全局变量 在properties定义标签，这个标签就是一个变量，标签的文本就是变量的值 使用全局变量表示多个依赖使用的版本号 使用方法： 在properties标签中定义一个标签，指定版本的值 1234567891011121314&lt;properties&gt; &lt;!-- 项目构建使用的编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 源码编译jdk版本 --&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;!-- 运行代码jdk版本 --&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- 生成报告的编码 --&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- 自定义变量 --&gt; &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt;&lt;/properties&gt; 使用自定义变量 1&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; 使用资源插件 处理的配置文件的信息，maven默认处理配置文件 maven会把src/main/resources目录下的文件，拷贝到target/classes目录下 maven只处理src/main/java目录中的java文件，把这些java文件编译为class，拷贝到target/classes目录中。不处理其他文件 资源插件：告诉maven要处理哪些文件 123456789101112131415&lt;build&gt; &lt;!--资源插件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/java/main&lt;/directory&gt;&lt;!--所在目录--&gt; &lt;includes&gt; &lt;!--目录下的properties和xml文件都会被扫描到--&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--不启用过滤器，*.preoperties已经起到过滤作用--&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;","categories":[],"tags":[]},{"title":"","slug":"JQuery","date":"2022-01-02T09:58:01.229Z","updated":"2021-08-29T08:02:46.322Z","comments":true,"path":"2022/01/02/JQuery/","link":"","permalink":"http://example.com/2022/01/02/JQuery/","excerpt":"","text":"JQueryJQuery是Js的一个库，存放用Js代码写的function，其简化了JS代码 你的第一个JQuery代码123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--指定jquery库文件位置--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;WEB-INF/JS/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /** * @$(document) $是JQuery中的函数名称，document是函数的参数，作用是document对象变成JQuery函数库可以使用的对象 * @ready 是JQuery中的函数，是准备的意思，当页面的dom对象加载成功后会执行ready函数的内容。ready相当于JS中的onLoad事件 * @function() 自定义的表示onLoad后要执行的代码功能 * */ //标准写法 /*$(document).ready(function () &#123; //自定义功能 alert(&quot;Hello JQuery&quot;) &#125;)*/ //简写方式 $(function () &#123; alert(&quot;Hello JQuery&quot;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 注意： 使用JQuery，首先要将JQuery库引入。使用第七行代码，此处src后面写你JQuery库文件存放的位置。 [^第七行代码]: $(document).ready()与jQuery()、$()、window.jQuery()是等价的，所以$(document).ready()可以写成$(function () { alert(“Hello JQuery”) }); DOM对象和JQuery对象DOM对象：使用Javascript的语法创建的对象叫做dom对象，也就是JS对象 JQuery对象：使用JQuery语法表示对象叫做JQuery对象，注意：JQuery表示的对象都是数组。 1234567//dom对象var obj = document.getElementById(&quot;text1&quot;);//jquery对象/**jobj就是使用jQuery语法表示的对象。也就是jQuery对象，它是一个数组，目前数组中只有一个值*/var jobj = $(&quot;#text1&quot;); DOM对象和jQuery对象可以相互转换 其转换的目的在于，使用DOM对象的属性、方法或者jQuery提供的函数 12345678//dom对象转换成jQuery对象$(domObj);//jQuery对象转换成dom对象/**从数组中获取第一个对象，第一个对象就是dom对象，使用[0]或者get(0)*/jObj[0];jObj.get(0); 基础部分选择器就是一个字符串，就是定位条件；通知jQuery函数定位满足条件的DOM对象 基础选择器根据ID，class属性，标签类型名定位HTML元素，转为JQuery对象 ID选择器：id在当前页面是唯一值 语法：$(“#dom对象的id值”) class选择器：class表示是css中的样式，使用样式的名称定位dom对象 语法：$(“.class样式名”) 标签选择器：使用标签名称定位dom对象 语法：$(“标签名称”) 所有选择器：选择所有对象 语法：$(“*”) 组合选择器：可以混合使用选择器 语法：$(“#id,标签名,.class”) 表单选择器使用标签的type属性值，定位dom对象 语法：$(“:type属性”) 过滤器jQuery对象中储存的DOM对象顺序与页面标签声明位置关系 12345&lt;div&gt;1&lt;/div&gt; dom1&lt;div&gt;2&lt;/div&gt; dom2&lt;div&gt;3&lt;/div&gt; dom2$(&quot;div&quot;) == [dom1,dom2,dom3] 过滤器就是过滤条件（字符串），对已经定位到数组的dom对象进行筛选，过滤条件不能独立出现在jQuery函数，如果使用只能出现在选择器后方 基础过滤器 first：选择第一个，保留数组中的第一个DOM对象 语法：$(“选择器:first”) last：选择最后一个，保留数组中最后一个DOM对象 语法：$(“选择器:last”) eq：选择数组中指定对象 语法：$(“选择器:eq(数组索引)”) lt：选择数组中小于指定索引的所有DOM对象 语法：$(“选择器:lt(数组索引)”) gt：选择数组中大于指定索引的所有DOM对象 语法：$(“选择器:gt(数组索引)”) 表单属性过滤器根据表单中dom对象的状态情况，定位dom对象的 常见的状态： enabled、disabled、checked、selected 语法： $(“text:enabled”) $(“text:disabled”) $(“radio:checked”) $(“选择器&gt;option:select”) jQuery函数 val 操作数组中DOM对象的value属性 $(选择器).val()：无参调用形式，读取数组中第一个DOM对象的value属性值 $(选择器).val(值)：有参调用形式，对数组中所有DOM对象的value属性值进行统一赋值 text 操作数组中所有DOM对象的文本显示内容 $(选择器).text()：无参调用形式，读取数组中所有DOM对象的文本显示内容，将得到内容拼接为一个字符串返回 $(选择器).text(值)：有参调用形式，对数组中所有DOM对象的文本显示内容进行统一赋值 attr 对val和text以外的其他属性操作 $(选择器).attr(“属性名”)：读取数组中第一个DOM对象的属性值 $(选择器).attr(“属性名”,”值”)：对数组中所有DOM对象的属性进行统一赋值 remove $(选择器).remove()：将数组中所有的DOM对象及其子对象一并删除 empty $(选择器).empty()：将数组中所有的DOM对象的子对象删除 append 为数组中所有的DOM对象添加子对象 $(选择器).append(“子对象”) html 设置或返回被选元素的内容（innerHTML） $(选择器).html()：无参调用，获取DOM数组第一个元素的内容 $(选择器).html(“值”)：有参调用，用于设置DOM数组所有元素的内容 each each是对数组，json和dom对象的遍历，对每个元素调用一次函数。 语法1：$.each(遍历对象,function(index,element){处理函数}) 语法2：jQuery对象.each(function(index,element){处理函数}) index：数组下标 element：数组对象 123456789101112131415161718192021222324252627var arr = [1,2,3]$.each(arr,function(index,element)&#123; alert(&quot;元素&quot;+index+&quot;值为&quot;+element)&#125;)//元素0值为1//元素1值为2//元素2值为3var json = &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;$.each(json,function(index,element)&#123; alert(&quot;key为&quot;+index+&quot;，value为&quot;+element)&#125;)//key为name，value为zhangsan//key为age，value为20/*&lt;button value=&quot;btn1&quot;&gt;1&lt;/button&gt;&lt;button value=&quot;btn2&quot;&gt;2&lt;/button&gt;&lt;button value=&quot;btn3&quot;&gt;3&lt;/button&gt;*/$(&quot;button&quot;).each(function(index,element)&#123; alert(&quot;元素&quot;+index+&quot;，value为&quot;+element.value+&quot;，innertext为&quot;+element.text)&#125;)//元素0，value为btn1，innertext为1//元素1，value为btn2，innertext为2//元素2，value为btn3，innertext为3 jQuery给DOM对象绑定事件语法1：$(选择器).事件名称(事件的处理函数) 语法2：$(选择器).on(事件名称,事件处理函数)————可以给新创建的对象绑定事件 注意： $(选择器)：定位dom对象，dom对象可以有多个，这些dom对象都绑定事件了 on：函数名称 事件名称：就是js中的事件名称去掉on，例如onclick == click 事件的处理函数：就是一个function，当事件发生时，会执行整个函数的内容。 使用jQuery的函数，实现ajax请求的处理在jQuery中简化了对ajax请求的处理，使用三个函数就可以实现ajax请求的处理 $.ajax()：ajax实现的核心函数 $.post()：使用post方式做ajax请求 $.get()：使用get方式做ajax请求 $.post()和$.get()在内部也是调用的$.ajax() $.ajax()的使用函数的参数表示请求的url，请求方式，参数值等信息； 参数是一个json格式，如下： 123456789101112$ajax(&#123; //async:true, //contentType:&quot;apllication/json&quot;, data:&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;, dataType:&quot;json&quot;, //error:function() &#123;/*发生错误时执行函数*/&#125;, success:function(data) &#123; //data 就是responseText，是jQuery处理后的数据 &#125;, url:&quot;myWeb&quot;, //type:&quot;get&quot;&#125;) 注意： async：是一个boolean类型值，默认为true，表示异步请求。可以不写 contentType：一个字符串，表示从浏览器发送给服务器的参数的类型。可以不写 例如表示参数类型为json，可以写application/json data：可以是字符串，数组，json，表示请求的参数和参数值。常用的是json格式的数据 dataType：表示期望从服务端返回的数据结构，可选：xml，html，text，json 服务器收到dataType的值，我们的servlet就能够知道客户端需要什么类型的数据，那么服务器就可以返回你需要的数据格式 error：一个function，表示当请求发送错误时，执行的函数 success：一个function，请求成功了，从服务端返回了数据，会执行success指定函数 url：请求地址 type：请求方式，get或者post，默认get","categories":[],"tags":[]},{"title":"","slug":"JDBC","date":"2022-01-02T09:58:01.227Z","updated":"2021-06-02T10:07:28.648Z","comments":true,"path":"2022/01/02/JDBC/","link":"","permalink":"http://example.com/2022/01/02/JDBC/","excerpt":"","text":"JDBC课前答疑JDBC是什么Java DataBase Connectivity （java语言连接数据库） 是SUN公司制定的一套接口（interface）：java.sql.*。 面向接口调用、面向接口写实现类等。 为什么要面向接口编程解耦合：降低程序的耦合度，提高程序的扩展力。 为什么由SUN指定一套JDBC接口因为每一个数据库的底层实现原理不同 JDBC编程六步123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.pjh.jdbc;import java.sql.*;import java.util.*;/** * @author yueyinghaibao * @date 2021/5/30 */public class Test03 &#123; public static void main(String[] args) &#123; /* * 实际开发中，使用属性资源文件绑定属性是被推荐的 */ //导入绑定配置文件 ResourceBundle bundle = ResourceBundle.getBundle(&quot;jdbc1&quot;); String driver = bundle.getString(&quot;driver&quot;); String url = bundle.getString(&quot;url&quot;); String user = bundle.getString(&quot;user&quot;); String password = bundle.getString(&quot;password&quot;); Connection connection = null; Statement statement = null; try&#123; //注册驱动 Class.forName(driver); //获取连接 connection = DriverManager.getConnection(url,user,password); System.out.println(&quot;数据库连接成功&quot;); //获取数据库操作对象 statement = connection.createStatement(); //执行SQL String sql = &quot;update t_student set classno = &#x27;g3c2&#x27; where no = 2&quot;; //executeUpdate专门执行DML语句（insert，delete，update），返回值是影响数据库中的记录条数 int count = statement.executeUpdate(sql); System.out.println(count == 1 ? &quot;true&quot; : &quot;false&quot;); //处理查询结果集 &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 //为了保证资源一定能够释放，在finally语句中执行关闭 //并且要遵循从小到大依次关闭 //分别对其try catch try&#123; if(statement != null)&#123; statement.close(); &#125; &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(connection != null)&#123; connection.close(); &#125; &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 第一步：注册驱动（告诉java程序，即将连接哪个数据库） 第二步：获取连接（表示JVM的进程和数据库进程之间的通道打开了，属于进程间的通讯，重量级的，使用完后一定要关闭通道） url：统一资源定位符（网络中某个资源的绝对路径） jdbc:mysql://127.0.0.1:3306/testwork ​ jdbc:mysql:// 通信协议 ​ 127.0.0.1 服务器IP地址 （此IP是本机IP，等同于localhost） ​ 3306 服务器上软件的端口 ​ testwork 服务器上某个资源的名称 通信协议：通信协议是通信之前提前订好的数据传送格式 第三步：获取数据库操作对象（专门执行SQL语句的对象） 第四步：执行SQL语句（DQL DML…） 第五步：处理查询结果集（只有第四步执行的select语句的时候，才有这第五步） 第六步：释放资源（使用完后一定要关闭资源，java和数据库属于进程间的通信，开启后一定要关闭） SQL注入问题sql注入问题即输入: fdsa fdsa’ or ‘1’ = ‘1’这种明显错误的密码也会登录成功原因在于用户输入的信息也参与了sql语句的编译 解决数据库sql注入问题只要用户提供的信息中不参与sql语句的编译 要达到以上目的，必须使用java.sql.PreparedStatement PreparedStatement接口继承了Statement PreparedStatement属于预编译的数据库操作对象 PreparedStatement原理是预先对sql语句的框架编译，在填入用户信息 Statement与PreparedStatement的比较 Statement存在sql注入问题，PreparedStatement解决了sql注入问题 前者时编译一次执行一次，后者是编译一次执行n次 后者会在编译阶段做类型的安全检查 综上所述，后者使用更多，前者使用少 只有在业务要求支持SQL语句注入或者SQL语句拼接时，才会使用前者 JDBC事务机制 JDBC中的事务是自动提交的 如若取消自动提交机制，使用代码 connection.setAutoCommit(false); 在取消自动提交后仍需要手动提交事务，此时使用代码 connection.commit(); 即可提交事务 如果在执行sql语句时遇到异常，需要在catch中回滚事务 if(connection != null){ ​ connection.rollback(); } 行级锁（SQL语句）在select语句最后加上for update表示行级锁，又称悲观锁： 作用是在事务结束前，将这行语句锁住，别人不能对它进行修改。 事务必须排队执行，数据锁住了，不允许并发。 乐观锁：支持并发，事务也不需要排队，只不过需要一个版本号。 ​","categories":[],"tags":[]},{"title":"","slug":"Java Web","date":"2022-01-02T09:58:01.225Z","updated":"2021-08-16T07:58:27.999Z","comments":true,"path":"2022/01/02/Java Web/","link":"","permalink":"http://example.com/2022/01/02/Java%20Web/","excerpt":"","text":"Java Web互联网通信 什么是互联网通信 两台计算机通过网络实现文件共享行为，就是互联网通信 互联网通信中的角色划分 客户端：用于发送请求的计算机 服务端：用于接受请求，并满足请求的计算机 互联网通信模型 C/S通信模型： client software（客户端软件） 客户端软件专门安装在客户端计算机上 帮助客户端计算机向指定服务端计算机发送请求，索要资源文件 帮助客户端计算机将服务端计算机发送回来的二进制数据文件解析为文字、图片、视频等形式 server software（服务器软件） 服务器软件专门安装在服务端计算机上 服务器软件用于接收来自于特定的客户端软件发送的请求 服务器软件在接收到请求后自动在服务端计算机上定位被访问的资源文件 服务器软件自动将定位的文件内容解析为二进制数据文件通过网络发送回发起请求的客户端软件上 适用场景：普遍用于个人娱乐市场，比如微信、淘宝、B站、大型网络游戏；企业办公应用较少 优缺点： 优点： 安全性较高 有效降低服务端计算机的工作压力 缺点： 增加客户获得服务的成本 更新较为繁琐 B/S通信模型： browser （浏览器） 浏览器安装在客户端计算机 可以向任意服务器发起请求，索要资源文件 可以将服务端计算机发送回来的二进制数据文件解析为文字、图片、视频等形式 server software （服务器软件） 服务器软件专门安装在服务端计算机上 可以接受任意浏览器发送的请求 自动在服务端计算机上定位被访问的资源文件 自动将定位的文件内容解析为二进制数据文件通过网络发送回发起请求的浏览器上 适用场景：既适用于个人娱乐市场，又广泛适用于企业日常活动 优缺点： 优点： 不会增加客户获得服务的成本 几乎不需要更新浏览器 缺点： 几乎无法有效的对服务端计算机资源文件进行保护 服务端计算机工作压力异常大 共享资源文件： 什么是共享资源文件： 可以通过网络进行传输的文件，都被称为共享资源文件 所有文件内容都可以通过网络传输，所有文件都是共享资源文件 HTTP服务器下对于共享资源文件分类： 静态资源文件 如果文件内容是固定的，这种文件可以称为静态资源文件（文档，图片，视频） 如果文件存放的是命令，这些文件只能在浏览器中编译和执行，这种文件可以称为静态资源文件（.html，.css，.js） 动态资源文件 如果文件存放命令，并且命令不能在浏览器中编译和运行，只能在服务端计算机编译运行，这样的文件称为动态资源文件（.class） 静态文件和动态文件调用区别 静态文件被索要时，Http服务器直接通过输出流将静态文件中内容或者命令以二进制形式推送给发起请求的浏览器 动态文件被索要时，Http服务器需要创建当前class文件的实例对象，通过实例对象调用对应的方法处理用户请求，通过输出流将运行结果以二进制形式推送给发起请求的浏览器 例如： 123456789101112class Function &#123; public add(int a, int b) &#123; int sum = a + b; return sum; &#125;&#125;/***这是一段class文件*http服务器会创建一个实例：Function function = new Function();*然后调用实例对象的方法：int sum = function.add(a,b);*最后将结果sum返回给发起请求的浏览器*/ 后端开发人员在互联网通信中担负的职责： 控制浏览器行为 控制浏览器请求行为 控制浏览器发送的请求地址 控制浏览器发送请求的方式 控制浏览器发送请求携带的参数 控制浏览器接受结果行为 控制浏览器采用对应编译器将接收到的二进制文件数据解析为文字、视频、图片、命令 控制浏览器将解析内容或者命令进行执行与展示（全局刷新展示/局部刷新展示） 控制用户与浏览器之间交流（JavaScript– &gt;jq） 开发动态资源文件（class）来解决用户请求 HTML 介绍： HTML编程语言是一种专门在浏览器编译与执行的编程语言 HTML编程语言学称超文本标记式编程语言 作用： HTML编程语言通知浏览器将接受的数据以指定方式在窗口展示[前端] 控制浏览器请求行为[前端/服务端工程师] 重点 HTML编程语言语法规范： HTML编程语言中所有命令都是声明在标签中，比如 HTML编程语言中的所有命令都是预先定义好的，不允许开发人员自行创建新的命令 HTML编程语言中的所有命令不区分英语字母大小写 HTML编程语言中命令开发时主要通过对命令中的属性进行赋值实现开发目的 属性赋值时内容可以包含在一个””中，也可以包含在一个’’，也可以省略，此时属性之间必须采用空格进行隔离 HTML编程语言中命令根据书写方式分为：双目标签命令和单目标签命令 双目标签命令书写时命令分别出现在开始标签和结束标签，比如 双目标签命令在书写时结束标签是不能省略的 单目标签命令书写时命令出现在一个标签内，比如 单目标签命令表示结束”/“可以省略不写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;html&gt; &lt;!-- 在一个HTML文件中，所有的HTML标签命令必须声明在&lt;html&gt;&lt;/html&gt; &lt;html&gt;&lt;/html&gt;包含两个子标签&lt;head&gt;&lt;/head&gt;和&lt;body&gt;&lt;/body&gt; &lt;head&gt;&lt;/head&gt;：设置基础参数信息 &lt;body&gt;&lt;/body&gt;：负责通知浏览器将指定内容以指定方式在窗口展示 --&gt; &lt;head&gt; &lt;meta charset=&#x27;utf-8&#x27;/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;h1&gt;&lt;/h1&gt;标题标签 数字可以在1-6中间选择，数字越大字体大小越小 &lt;p&gt;&lt;/p&gt;段落标签：包含其中的字符为一段话，段落结尾自动换行 --&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;p&gt; Hello,World!&lt;/p&gt; &lt;p&gt; Hello,World!&lt;/p&gt; &lt;!-- &lt;ol&gt;&lt;/ol&gt;有序标签 &lt;ul&gt;&lt;/ul&gt;无序标签 子标签&lt;li&gt;&lt;/li&gt;：该标签会根据序列标签给其中的展示内容顺序添加序号或无序添加小圆点 序列标签可以嵌套 这些标签主要用于制作导航页 --&gt; &lt;ol&gt; &lt;li&gt;中国&lt;/li&gt; &lt;li&gt;美国&lt;/li&gt; &lt;li&gt;俄罗斯&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;米饭&lt;/li&gt; &lt;li&gt;面包&lt;/li&gt; &lt;li&gt;西伯利亚大土豆&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;中国 &lt;ol&gt; &lt;li&gt;米饭&lt;/li&gt; &lt;li&gt;面条&lt;/li&gt; &lt;li&gt;包子&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;美国 &lt;ol&gt; &lt;li&gt;面包&lt;/li&gt; &lt;li&gt;牛排&lt;/li&gt; &lt;li&gt;炸鸡&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;俄罗斯 &lt;ol&gt; &lt;li&gt;西伯利亚大土豆&lt;/li&gt; &lt;li&gt;赫鲁晓夫大玉米&lt;/li&gt; &lt;li&gt;坚不可摧大列巴&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- &lt;table&gt;&lt;/table&gt;表格标签 子标签&lt;tr&gt;&lt;/tr&gt;：行 子标签&lt;td&gt;&lt;/td&gt;：单元格 属性 border：表格边框宽度 align：文本对齐方式 style：更改默认样式 rowspan：设置单元格高度 colspon：设置单元格宽度 --&gt; &lt;table border=&quot;2&quot; align=&quot;center&quot;&gt; &lt;tr style=&quot;background-color:blue&quot;&gt; &lt;td&gt; 国家 &lt;/td&gt; &lt;td&gt; 中国 &lt;/td&gt; &lt;td&gt; 美国 &lt;/td&gt; &lt;td&gt; 俄罗斯 &lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td rowspan=&quot;3&quot;&gt; 食物 &lt;/td&gt; &lt;td&gt; 米饭 &lt;/td&gt; &lt;td&gt; 面包 &lt;/td&gt; &lt;td&gt; 土豆 &lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt; 面条 &lt;/td&gt; &lt;td&gt; 牛排 &lt;/td&gt; &lt;td&gt; 玉米 &lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; style=&quot;background-color:yellow&quot;&gt; &lt;td&gt; 包子 &lt;/td&gt; &lt;td&gt; 炸鸡 &lt;/td&gt; &lt;td&gt; 大列巴 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- &lt;img/&gt;图片标签：在浏览器中展示一张图片 &lt;center&gt;&lt;/center&gt;居中格式 &lt;div&gt;&lt;/div&gt;内容展示方块 &lt;font&gt;&lt;/font&gt;文字标签：展示一行文字 属性 src：图片的地址 title：图片的标题 width：宽度 height：高度 --&gt; &lt;center&gt; &lt;div&gt; &lt;font style=&quot;font-size:50&quot;&gt;我看不懂但我大受震撼&lt;/font&gt; &lt;/div&gt; &lt;img src=&quot;OIP.jpg&quot; title=&quot;猫&quot;/&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 浏览器发送请求的三要素：(very important) 控制浏览器发送的请求地址 超链接标签命令： 格式： 1&lt;a href=&quot;请求地址&quot;&gt;提示信息&lt;/a&gt; 百度一下 淘宝：淘你所想 Myjpg 工作原理： 不会被浏览器自动执行，在用户单击超链接标签命令时，这个命令才会执行 执行要求浏览器立刻按照href属性地址发送请求 表单标签命令 格式： 123&lt;form action=&quot;请求地址&quot;&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;!--提交按钮--&gt;&lt;/form&gt; 工作原理： 不会被浏览器自动执行，在用户单击提交按钮时，这个命令才会执行 执行时要求浏览器立刻按照action属性地址发送请求 控制浏览器发送请求的方式 请求方式：决定浏览器发送请求时的行为特征 浏览器可以选择请求方式：7种，目前只考虑POST请求方式和GET请求方式 GET请求方式： 要求浏览器发送请求时，其携带的请求参数数量不能超过4K（超量截断） 要求浏览器发送请求时，必须在浏览器地址栏上将请求参数信息展示出来 要求浏览器发送请求时，必须将请求参数信息保存在HTTP请求协议包中的请求头 要求浏览器在接收到服务器返回的资源文件内容后，必须将资源文件内容保存在浏览器的缓存中 POST请求方式： 要求浏览器发送请求时，可以携带任意数量的请求参数 要求浏览器发送请求时，必须在浏览器地址栏隐藏请求参数信息 要求浏览器发送请求时，必须将请求参数信息保存在HTTP请求协议包中的请求体 禁止浏览器将服务器返回资源文件内容进行保存 控制浏览器发送请求时采用GET请求方式 超链接标签命令 表单标签存在一个method属性，通过这个属性可以要求浏览器采用对应请求方式发送请求，默认为GET方式 控制浏览器发送请求时采用POST请求方式 表单标签method属性设置为POST方式： 请求方式的适用场景 考虑到post请求方式，用户可以将病毒发送到服务器上进行攻击，因此绝大多数门户网站拒绝接受POST请求，日常开发过程中绝大多数请求都是GET 在某些特殊场景下必须使用POST 文件上传 发起登录验证请求 索要服务器中实时变化数据时 控制浏览器发送请求携带的参数 请求参数作用： 当用户通过浏览器访问服务端计算机动态资源文件时，往往需要调用其中的方法。 浏览器发送请求时需要携带调用方法需要的实参（请求参数） 请求参数格式： 浏览器发送请求时：请求地址?请求参数1=值&amp;请求参数2=值2 浏览器发送请求时携带的请求参数来源： 通过超链接标签命令指定请求参数 例如：百度 弊端：这种方式发送的请求参数内容时固定的 通过表单域标签命令指定请求参数 一组声明在form标签内部的标签命令 提示用户填写请求参数内容，用于提供相对灵活的请求参数内容 所有表单域标签都有两个属性name和value name属性声明请求参数名，value属性声明请求参数值 例如： 表单域标签分类： ```html形式： 用户姓名: 用户密码: 用户性别:男 女 擅长技术:JAVA C++ MySql 用户头像: 123456789101112131415 2. ```html &lt;select&gt;&lt;/select&gt;形式 &lt;form action=&quot;http://www.baidu.com&quot;&gt; 籍贯:&lt;select name=&quot;home&quot;&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;tj&quot;&gt;天津&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;input type=&quot;reset&quot;/&gt; &lt;/form&gt; ```html 用户姓名: 用户密码: 用户性别:男 女 擅长技术:JAVA C++ MySql 用户头像: 备注信息:&lt;textarea name=&quot;ta&quot; rows=&quot;5&quot; cols=&quot;30&quot;&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;!--文本栏，rows和cols分别设置展示的行数和列数--&gt; &lt;input type=&quot;submit&quot;/&gt;&lt;!--用于提交请求参数--&gt; &lt;input type=&quot;reset&quot;/&gt;&lt;!--用于重置请求参数--&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 - 表单域标签value属性默认值 1. 大多数表单域标签value属性默认是空字符串，例如：username=&#x27;&#x27; 2. 对于radio和checkbox来说，value属性默认值为&#x27;on&#x27;的字符串 - 表单域标签作为请求参数条件 对于大多数表单域标签来说，只要同时满足以下两个条件，就可以作为请求参数 1. 必须声明在form标签内 2. 必须声明name参数 对于radio和checkbox标签来说在满足上述两个条件的同时，还需要满足第三个条件才可以作为请求参数 3. radio和checkbox必须在被选中的情况下才可以作为请求参数 此外，如果表单域标签用disabled来修饰，则它不能作为请求参数发送给服务端 顺带一提readonly和disabled的区别： - readonly：设置当前标签只能读不能修改，readonly不会影响表单域标签作为请求参数条件 - disabled：设置当前标签为不可用状态，此时标签中的value不能被修改，disabled修饰的表单域标签永远不能作为请求参数发送给服务端## CSS- 是一种专门在浏览器编译并执行的编程语言 用于定位浏览器中**HTML标签**并对定位的HTML标签中**样式属性**进行统一管理- HTML标签属性分类 - 基本属性： 大多数HTML标签都拥有的属性，是一个很庞大的群体 比如id属性，用来区分HTML标签，不允许有相同的id 比如name属性，允许一组标签有相同的name - 样式属性： 是一个非常庞大的群体，通知浏览器将HTML标签中的数据在浏览器中以指定形态展示 比如&lt;div style=&quot;background-color:red;width:300;height:300&quot;&gt;&lt;/div&gt; - 工作状态属性： 只存在于表单域标签中，用于表示表单域标签状态 check：存在于radio和checkbox中，表示标签是否被选中 disabled：表示标签处于不可用的状态 readonly：表示标签处于只读状态 selected：存在于option标签中，表示标签是否被选中 - 监听属性： 监听属性用户与HTML标签之前进行通信，监听属性用于监听用户再何时对当前标签进行何种操作，当指定操作产生时，监听属性将会通知浏览器调用对应的JavaScript方法来处理当前请求- 样式属性开发难度： - 由于网页经常出现大量的HTML标签拥有相同的样式属性设置，因此导致前端工程师进行大量重复性开发操作 - 当用户修改需求时，导致前端工程师进行大量重复维护工作- CSS的作用 - 通知浏览器将所有满足定位条件的HTML标签进行统一定位 - 通知浏览器对已经定位HTML标签中样式属性进行集中统一赋值管理- CSS选择器： - 实际上就是一组定位条件用于定位HTML标签，有9个大类 - 语法格式： ```html &lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; 定位条件&#123; 样式属性1:值1; 样式属性2:值2 &#125; &lt;/style&gt; &lt;/head&gt; &lt;/html&gt; ID选择器： 根据HTML标签中ID属性的值进行定位 语法： 123456&lt;style type=&quot;text/css&quot;&gt; #id编号&#123; 样式属性1:值1; 样式属性2:值2 &#125;&lt;/style&gt; 标签类型选择器： 根据HTML标签类型进行定位 语法 123456&lt;style type=&quot;text/css&quot;&gt; 标签类型名&#123; 样式属性1:值1; 样式属性2:值2 &#125;&lt;/style&gt; 层级选择器 HTML标签之间的关系： 父子关系：即包含关系 兄弟关系：一组标签拥有相同的父标签，并且彼此之间没有任何包含关系，即为兄弟 根据标签之间的关系进行定位 示例： 1234567&lt;!--父子关系--&gt;&lt;style type=&quot;text/css&quot;&gt; 定位父标签条件 定位子标签条件&#123; 样式属性1:值1; 样式属性2:值2 &#125;&lt;/style&gt; 自定义选择器 如果一组HTML标签没有相同的特征，但是需要对指定属性赋值相同的内容，此时将自定义选择器绑定到对应的标签上 语法： 12345678&lt;style type=&quot;text/css&quot;&gt; .自定义选择器名&#123; 样式属性1:值1; 样式属性2:值2 &#125;&lt;/style&gt;&lt;div class=&quot;自定义选择器名&quot;&gt;&lt;/div&gt;&lt;p class=&quot;自定义选择器名&quot;&gt;&lt;/p&gt; HTTP网络协议包 网络协议包： 在网络中传递信息都是以二进制形式存在的 接收方浏览器/服务器在接收到信息后，要做的第一件事就是将二进制数据进行编译成文字、图片、视频、命令 传递信息数据量往往比较巨大，导致接收方很难在一组连续二进制得到对应数据 网络协议包是一组有规律的二进制数据，在这组数据存在固定空间，每一个空间专门存放特定信息，这样接收方在接收到网络协议包之后就可以到固定空间得到对应信息，网络协议包出现极大降低了接收方对接收二进制数据编译难度 常见网络协议包： FTP网络协议包（文件传输协议） HTTP网络协议包（超文本传输协议） 在基于B/S结构下互联网通信过程中，所有网络中传递信息都是保存在HTTP网络协议包 分类： HTTP请求协议包 在浏览器准备发送请求时，负责创建与一个HTTP请求协议包 浏览器将请求信息以二进制形式保存在HTTP请求协议包各个空间 由浏览器负责将HTTP请求协议包推送到指定服务端计算机 内部空间： 按照自上而下去划分，分为四个空间 空间划分： 请求行：包括URL（请求地址）和method（请求方式） 请求头：包括请求参数信息（GET） 空白行（不可见）：没有任何内容，起到隔离作用 请求体（不可见）：包括请求参数信息（POST） HTTP响应协议包 HTTP服务器在定位到被访问的资源文件之后，负责创建一个HTTP响应协议包 HTTP服务器将定位文件内容或者文件命令以二进制形式写入到HTTP响应协议包各个空间 由HTTP服务器负责将HTTP响应协议包推送回发起请求的浏览器上 内部空间： 按照自上而下去划分，分为四个空间 空间划分： 状态行：包括HTTP状态码 响应头：包括content-type（内容类型属性）指定浏览器采用对应编译器对响应体中的二进制数据进行解析 空白行：没有任何内容，起到隔离作用 响应体：可能包括被访问的静态资源文件内容、静态资源文件命令、动态资源文件运行结果（二进制形式） HTTP服务器 服务器：是一种安装在服务端计算机的资源文件调度器，每一种服务器专门接受特定的请求协议。对特定的文件进行调度管理。 HTTP服务器是服务器中一种，其行为和HTTP协议相关 HTTP服务器可以接收来自浏览器发送的HTTP请求协议包，并自动对HTTP请求协议包内容进行解析 解析后，自动定位被访问的文件，并将定位的文件内容写入到HTTP响应协议包中 最后，负责将HTTP响应协议包推送回发起请求的浏览器上 分类： JBOSS服务器：不支持servlet/JSP规范，一般和Tomcat和Jetty绑定使用 Glassfish服务器（开发中）：未来可期，颠覆式的改变现如今的服务器体系。 Jetty服务器： Weblogic服务器： Websphere服务器：目前最强大的web服务器，往往运用在电子商务应用领域。主要安装在Linux中 Tomcat服务器：轻量化且标准化规范，但不适用于中大型系统和高并发状态，因此往往安装在个人计算机中以模拟B/S互联网通讯流程。 Tomcat服务器 Tomcat服务器内部工作文件作用： bin文件夹：Tomcat管理命令 conf文件夹：Tomcat配置文件 lib文件夹：Tomcat使用的jar logs文件夹：Tomcat日志信息 temp文件夹：Tomcat临时文件 webapps文件夹：Tomcat默认资源文件 work文件夹：Tomcat工作空间 创建网站 步骤略 网站内部结构 src文件夹：存放作为动态资源文件的Java文件 web文件夹： 存放作为静态资源文件图片、HTML、CSS、js； 存放网站运行时依赖的jar MYSQL驱动； 存放网站的核心配置文件（web.xml） WEB-INF：依赖的jar MYSQL驱动/核心配置文件 lib文件夹：依赖的jar MYSQL驱动 web.xml：通知Tomcat当前网站那些Java类是 Servlet规范 Servlet规范来自于JAVAEE规范中的一种 作用： 在Servlet规范中，指定动态资源文件开发步骤 在Servlet规范中，指定HTTP服务器调用动态资源文件的规则 在Servlet规范中，指定HTTP服务器管理动态资源文件实例对象规则 Servlet接口实现类： Servlet接口来自于Servlet规范下的一个接口，这个接口存在HTTP服务器提供jar包 Tomcat服务器下lib文件有一个Servlet-api.jar存放servlet接口（javax.servlet.Servlet接口） Servlet规范中认为，HTTP服务器能调用的动态资源文件必须是一个Servlet接口实现类 包含的方法： init getServletConfig service——唯一有用需要我们自己实现的方法 getServletInfo destroy Tomcat根据Servlet规范调用Servlet接口实现类规则： Tomcat有权创建Servlet接口实现类实例对象： Servlet oneServlet = new OneServlet(); Tomcat根据实例对象调用service方法处理当前请求： oneServlet.service(); service方法实际是由父类HttpServlet实现的，大体为： 12345678void service() &#123; Method method = getMethod(); if(method == &quot;GET&quot;) &#123; this.doGet(); &#125; else if(method == &quot;POST&quot;) &#123; this.doPost(); &#125;&#125; 在子类OneServlet中实现doGet或doPost方法 通过父类决定在何种情况下调用子类中的方法——设计模式——模板设计模式 Servlet接口实现类开发步骤 创建一个java类继承于HttpServlet父类，使之成为一个Servlet接口实现类 重写HttpServlet父类两个方法：doGet或者doPost 将Servlet接口实现类信息注册到Tomcat服务器： 网站==&gt;web==&gt;WEB-INF==&gt;web.xml 123456789101112131415&lt;!--将servlet接口实现类类路径地址交给Tomcat--&gt;&lt;servlet&gt; &lt;servlet-name&gt;one&lt;/servlet-name&gt;&lt;!--声明一个变量储存servlet接口实现类路径--&gt; &lt;servlet-class&gt;com.pjh.controller.OneServlet&lt;/servlet-class&gt;&lt;!--声明一个servlet接口实现类路径--&gt;&lt;/servlet&gt;&lt;!-- 此时 Tomcat String one = &quot;com.pjh.controller.OneServlet&quot; 为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;one&lt;/servlet-name&gt; &lt;url-pattern&gt;/one&lt;/url-pattern&gt;&lt;!--设置简短的请求别名，别名在书写时必须以/开头--&gt;&lt;/servlet-mapping&gt; Servlet对象生命周期： 网站中所有的Servlet接口实现类的实例对象，都是由HTTP服务器负责创建 开发人员不能手动创建Servlet接口实现类的实例对象 在默认情况下，HTTP服务器接收到对于当前Servlet接口实现类第一次请求时自动创建这个Servlet接口实现类的实例对象 在手动配置情况下，要求HTTP服务器在启动时自动创建某个Servlet接口实现类的实例对象 12345&lt;servlet&gt; &lt;servlet-name&gt;one&lt;/servlet-name&gt;&lt;!--声明一个变量储存servlet接口实现类路径--&gt; &lt;servlet-class&gt;com.pjh.controller.OneServlet&lt;/servlet-class&gt;&lt;!--声明一个servlet接口实现类路径--&gt; &lt;load-on-startup&gt;30&lt;/load-on-startup&gt;&lt;!--填写一个大于0的整数即可--&gt;&lt;/servlet&gt; 在HTTP服务器运行期间，一个Servlet接口实现类只能被创建一个实例对象 在HTTP服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁 HttpServletResponse接口和HttpServletRequest接口 HttpServletResponse接口： HttpServletResponse接口来自于Servlet规范中，存在于Tomcat的servlet-api.jar中 HttpServletResponse接口实现类由Http服务器负责提供 HttpServletResponse接口负责将doGet或者doPost方法执行结果写入到响应体交给浏览器 开发人员习惯于将HttpServletResponse接口修饰的对象称为响应对象 主要功能： 将执行结果以二进制形式写入到响应体中 设置响应头中content-type属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为文字、图片、视频、命令 设置响应头中location属性，将一个请求地址赋值给location从而控制浏览器向指定服务器发送请求 1234567891011@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String result = &quot;Hello World&quot;; //响应对象将结果写入到响应体中——start //通过响应对象向Tomcat索要输出流 PrintWriter out = response.getWriter(); //通过输出流，将执行结果以二进制形式写入响应体中 out.write(result); //或者out.print(); 会将一切数据当作字符串打印出来 //而write会将数字当作ascii码&#125; 浏览器在接收到相应包之后，根据响应头中content-type属性的值，来采用对应编译器对响应体中二进制内容进行编译处理，在默认情况下，content-type属性的值为”text”，此时浏览器会采用文本编译器对响应体二进制数据进行解析。 因此若需要编译命令，则一定要在得到输出流之前，通过响应对象对响应头中的content-type属性进行一次重新赋值用来指定浏览器采用正确的编译器 通过sendRedirect方法可以远程控制浏览器请求行为：请求地址，请求方式，请求参数。例如，当响应头中存在location属性，则会自动通过地址栏向location指定网站发送请求。 HttpServletRequest接口 HttpServletRequest接口来自于Servlet规范中，存在于Tomcat的servlet-api.jar中 HttpServletRequest接口实现类由Http服务器负责提供 HttpServletRequest接口负责在doGet/doPost方法运行时读取Http请求协议包中信息 开发人员习惯于将HttpServletResponse接口修饰的对象称为请求对象 主要功能： 读取Http请求协议包中请求行信息 可以读取保存在Http请求协议包中请求头或者请求体中请求参数信息 可以代替浏览器向Http服务器申请资源文件调用 12345678910111213141516171819202122//通过请求对象，读取请求行中url信息String url = request.getRequestURL().toString();//通过请求对象，读取请求行中method信息String method = request.getMethod();//通过请求对象，读取请求行中uri属性/** URI:资源文件精准定位地址，在请求行并没有URI这个属性* 实际上是URL中截取的一个字符串，* 这个字符串格式：/网站名/资源文件名* URI用于让Http服务器对被访问的资源文件进行定位*/String uri = request.getRequestURI();//通过请求对象获得请求头中所有请求参数名//将所有请求参数名称保存在一个枚举对象进行返回Enumeration&lt;String&gt; parameterNames = request.getParameterNames();while(parameterNames.hasMoreElements()) &#123; String paramName = parameterNames.nextElement(); //通过请求对象读取指定的请求参数的值 String parameter = request.getParameter(paramName); System.out.println(&quot;请求参数名称：&quot;+paramName+&quot; 请求参数值：&quot;+parameter);&#125; 当用Post方式发送中文参数时，getParameter得到了乱码，其原因在于： 浏览器以GET方式发送请求，请求参数保存在请求头里，在Http服务器之后，第一件事就是进行解码。请求头二进制数据由Tomcat负责解码，Tomcat9.0默认使用utf-8字符集，可以解释一切国家文字 而以Post方式发送请求，请求参数保存在请求体里，在Http服务器之后，第一件事就是进行解码。请求体二进制数据由request请求对象负责解码，默认使用ISO-8859-1字符集，如果请求参数内容为中文，将无法解码 解决方案： 在post请求方式下，在读取请求体内容前，应该通知请求对象使用utf-8对请求参数重新解码 1request.setCharacterEncoding(&quot;utf-8&quot;); 请求对象和响应对象的生命周期： 在Http服务器在接收到浏览器发送的Http请求协议包之后，自动为当前Http请求协议包生成一个请求对象和响应对象 在Http服务器调用doGet/doPost方式时，负责将请求对象和响应对象作为实参传递到方法，确保doGet/doPost正确执行 在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的请求对象和响应对象销毁 请求对象和响应对象生命周期贯穿一次请求的处理过程中 请求对象和响应对象相当于用户在服务端得代言人 欢迎资源文件 前提：用户只会记住网站名，不会记住网站里的资源文件 默认欢迎资源文件：用户向Http服务器发送针对某个网站的默认请求，服务器自动从当前网站返回的资源文件 Tomcat对于默认欢迎资源文件定位规则 规则位置：Tomcat安装位置/conf/web.xml 12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 设置默认欢迎资源文件规则 规则位置：网站/web/WEB-INF/web.xml 规则命令： 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;login.html&lt;/welcome-file&gt; &lt;welcome-file&gt;user/find&lt;/welcome-file&gt;&lt;!--servlet作为默认欢迎资源时，开头斜线必须抹掉--&gt;&lt;/welcome-file-list&gt; 网站设置自定义默认文件定位规则，此时Tomcat自带的定位规则将失效 Http状态码： 是有三位数字组成的一个符号 Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中状态行上 如果Http服务器针对本次请求，返回了对应资源文件。通过Http状态码通知浏览器应该如何处理这个结果 如果Http服务器针对本次请求，无法返回对应资源文件。通过Http状态码向浏览器解释无法提供服务的原因 分类： 组成：100-599，分为5个大类 1xx： 最有特征的100：通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收响应包后，继续向Http服务器索要依赖的其他资源文件 2xx： 最有特征的200：通知浏览器本次返回的资源文件是一个独立的资源文件，浏览器在接收响应包后不需要继续向Http服务器索要其他资源文件 3xx： 最有特征的302：通知浏览器本次返回的不是一个资源文件，而是一个资源文件地址，需要浏览器根据这个地址向Http服务器索要这个资源文件 例如response.sendRedirect(“资源文件地址”)写入到响应头中location 而这个行为导致Tomcat将302写入状态行 4xx： 最有特征的404：通知浏览器，由于在服务端没有定位到被访问的资源文件，因此无法提供帮助 最有特征的405：通知浏览器，在服务端已经定位到被访问的资源文件（servlet），但是这个servlet对于浏览器发送的请求方式无法处理 5xx： 最有特征的500：通知浏览器，在服务端已经定位到被访问的资源文件（servlet），这个servlet对于浏览器发送的请求方式可以处理，但是servlet在处理时，由于java异常导致处理失败 多个Servlet之间调用问题（重点）： 前题条件： 某些来自于浏览器发送请求，往往需要服务端中多个servlet协同处理。但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。 这样增加用户获得服务难度，导致用户放弃访问当前网站 提高用户使用感受规则： 无论本次请求涉及到多少个Servlet，用户只需要手动通知浏览器发起一次请求即可 调用规则： 重定向解决方案： 工作原理： 用户第一次通过手动方式通知浏览器访问OneServlet，OneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将302状态码写入到状态行。 在浏览器接收到这个响应包后，会读取到302状态，此时浏览器自动根据响应头中location属性地址发起第二次请求，访问TwoServlet去完成请求中剩余任务 实现命令： response.sendRedirect(“请求地址”) 将地址写入到响应包中响应头中location属性 特征： 请求地址： 即可以把当前网站内部的资源文件地址发送给浏览器（/网站名/资源文件名） 也可以把其他网站的资源文件地址发送给浏览器（http://ip地址:端口号/网站名/资源文件名） 请求次数： 浏览器至少发送两次请求，但只有第一次是用户手动发送的，后续请求都是由浏览器自动发送 请求方式： 重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用资源文件接收方式一定是GET 缺点： 重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务的时间 请求转发解决方案： 工作原理： 用户第一次通过手动方式通知浏览器访问OneServlet，OneServlet工作完毕后，通过当前请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。 Tomcat接收到这个请求后，自动调用TwoServlet去完成剩余任务 实现命令：请求对象代替浏览器向Tomcat发送请求 通过当前请求对象生成资源文件申请报告对象： RequestDispatcher report = request.getRequestDispatcher(“/资源文件名”); 一定要以/为开头且不要写网站名 将报告对象发送给Tomcat： report.forward(当前请求对象，当前响应对象); 优点： 无论本次涉及到多少个servlet，用户只需要手动通过浏览器发送一次请求 servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数增加处理服务速度 特征： 请求次数： 浏览器只发送一次请求 请求地址： 只能向Tomcat服务器申请调用当前网站内部的资源文件 请求方式： 在请求转发过程中，浏览器只发送了一个Http请求协议包。参与本次请求转发的所有Servlet共享同一个请求协议包，因此这些Servlet接收的请求方式与浏览器发送的请求方式保持一致 多个Servlet之间数据共享实现方案： 数据共享：OneServlet工作完毕后，将产生数据交给TwoServlet来使用 Servlet规范中提供四种方案： ServletContext接口 来自于Servlet规范的一个接口。在Tomcat中存在servlet-api.jar。在Tomcat中负责提供这个接口实现类 如果两个servlet来自同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享 开发人员习惯于将ServletContext对象称为全局作用域对象 工作原理： 每个网站都存在一个全局作用域对象，这个全局作用域对象相当于一个map，在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用 全局作用域对象生命周期： 在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象 在Http服务器运行期间，一个网站只存在一个全局作用域对象 在Http服务器运行期间，全局作用域对象一直存活 在Http服务器准备关闭时，负责将当前网站中全局作用域对象进行销毁处理 全局作用域对象生命周期贯穿网站整个运行期间 命令实现：one共享给two 1234567891011121314151617public OneServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //通过请求对象向Tomcat所有当前网站的全局作用域对象 ServletContext application = request.getServletContext(); //将数据添加到全局作用域对象作为共享数据 application.setAttribute(&quot;key1&quot;,data); &#125;&#125;//————————————————————————————————————————————————————————————————public TwoServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //通过请求对象向Tomcat所有当前网站的全局作用域对象 ServletContext application = request.getServletContext(); //从全局作用域对象得到指定关键字对应数据 Object data = application.getAttribute(&quot;key1&quot;); &#125;&#125; Cookie类 Cookie来自于Servlet规范中的一个工具类，存在于Tomcat提供servlet-api.jar中 如果两个servlet来自同一个网站，并且为同一个浏览器/用户提供服务，此时可以借助Cookie对象进行数据共享 Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量 原理： 用户通过浏览器第一次向网站发送请求申请OneServlet。OneServlet在运行过程中创建一个Cookie储存与当前用户相关数据。OneServlet工作完毕后，将Cookie写入到响应头交还给当前浏览器。 浏览器收到响应包后，将Cookie存储在浏览器的缓存一段时间后，用户通过同一个浏览器再次向同一个网站发送请求申请TwoServlet时。浏览器需要无条件的将网站之前推送的Cookie，写入请求头中发送过去。 此时TwoServlet在运行时，就可以通过读取请求头中Cookie的信息，得到OneServlet提供的共享数据 实现命令：one共享给two 123456789101112131415161718192021public OneServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //创建一个Cookie对象，保存共享数据（当前用户数据） Cookie card = new Cookie(&quot;key1&quot;,&quot;abc&quot;); //Cookie相当于一个map，但是只能存放一个键值对，这个键值对中的key和value只能是String,key不能是中文 //将Cookie写入到响应头，交给浏览器 response.addCookie(card); &#125;&#125;//————————————————————————————————————————————————————————————————public TwoServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //调用请求对象从请求头得到浏览器返回的Cookie Cookie[] cookieArray = request。getCookie(); //循环遍历数据得到每个cookie的key和value for(Cookie card:cookieArray) &#123; String key = card.getName(); String value = card.getValue(); &#125; &#125;&#125; 生命周期 在默认情况下，Cookie对象存在在浏览器缓存中，浏览器关闭Cookie就销毁了 在手动设置情况下，可以要求浏览器将接收的Cookie存放在客户端计算机上硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器关闭客户端计算机，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除 1Cookie.setMaxAge(60); HttpSession接口 HttpSession来自于Servlet规范中的一个接口，存在于Tomcat提供servlet-api.jar中。其实现类由Http服务器提供，Tomcat提供实现类存在于Servlet-api.jar中 如果两个servlet来自同一个网站，并且为同一个浏览器/用户提供服务，此时可以借助HttpSession对象进行数据共享 开发人员习惯于将HttpSession对象称为会话作用域对象 HttpSession与Cookie的区别： 存储位置： Cookie存放在客户端计算机中(浏览器内存/硬盘)； HttpSession存放在服务端计算机内存 数据类型： Cookie对象储存共享数据类型只能是String HttpSession对象可以储存任意类型的共享数据object 数据数量： 一个Cookie只能储存一个共享数据 HttpSession使用map集合储存共享数据，所以可以储存任意数量共享数据 命令实现： 1234567891011121314151617181920public class OneServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //调用请求对象向Tomcat索要当前用户在服务端的储物柜 HttpSession session = request.getSession(); //将数据储存到用户的储物柜 session.setAttribute(&quot;key1&quot;,共享数据); &#125;&#125;public TwoServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //调用请求对象向Tomcat索要当前用户在服务端的储物柜 HttpSession session = request.getSession(); //从会话作用域中得到OneServlet提供的共享数据 Enumeration goods = session.getAttribute(); while(goods.hasMoreElements())&#123; String goodsName = (String)goods.nextElement(); int goodsNum = (int)session.getAttribute(goodsName); &#125; &#125;&#125; Http服务器是怎么把HttpSession和浏览器关联起来的 Tomcat在创建一个HttpSession对象时，自动为这个HttpSession对象生成一个唯一编号 Tomcat将编号保存到Cookie对象，推送到当前浏览器缓存 Cookie：JSESSIONID = “” 当到用户第二次来访时，Tomcat根据请求头JSESSIONID确认用户是否有HttpSession以及哪一个HttpSession是该用户的 getSession()和getSession(false) getSession()：如果当前用户在服务端已经拥有了自己的私人储物柜要求Tomcat将这个私人储物柜进行返回。如果当前用户尚未在服务端拥有自己的私人储存柜，会创建一个新的。 getSession()：如果当前用户在服务端已经拥有了自己的私人储物柜要求Tomcat将这个私人储物柜进行返回。如果当前用户尚未在服务端拥有自己的私人储存柜，会返回一个null。 HttpSession销毁时机： 用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中； 在浏览器关闭时，意味着用户与他的HttpSession关系切断； 由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会导致Tomcat将关联的HttpSession进行销毁； 为了解决这个问题，Tomcat为每一个HttpSession对象设置空闲时间，这个空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟，此时Tomcat认为用户放弃了自己的HttpSession，此时Tomcat就会销毁掉这个HttpSession。 HttpSession空闲时间手动设置 1234&lt;!--在web.xml中--&gt;&lt;session-config&gt; &lt;session-timeout&gt;5&lt;/session-timeout&gt; &lt;!--中间填空闲时间--&gt;&lt;/session-config&gt; HttpServletRequest接口 在同一个网站中，如果两个Servlet之间通过请求转发方式进行调用，彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象因此Servlet之间共享同一个请求对象，此时可以利用这个请求对象在两个Servlet之间实现数据共享 在请求对象那个实现Servlet之间数据共享功能时，开发人员将请求对象称为请求作用域对象 命令实现： 123456789101112131415public class OneServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //将数据添加到请求作用域对象中attribute属性 request.setAttribute(&quot;key1&quot;,data); //向Tomcat申请调用TwoServlet request.getRequestDispatcher(&quot;/two&quot;).forward(request,response); &#125;&#125;public TwoServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; //从当前请求对象得到OneServlet写入到共享数据 Object data = request.getAttribute(&quot;key1&quot;); &#125; &#125;&#125; Servlet规范拓展 监听器接口——Listener接口： 介绍： 一组来自于servlet规范下的接口，共有八个。存在于Tomcat提供servlet-api.jar中。 监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类 监听器接口用于监控作用域对象生命周期变化时刻以及作用域对象共享数据变化时刻 作用域对象： 在Servlet规范中，认为在服务端内存中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为作用域对象 类型： ServletContext：全局作用域对象 HttpSession：会话作用域对象 HttpServletRequest：请求作用域对象 监听器接口实现类开发规范：三步 根据监听的实际情况，选择对应监听器接口进行实现 重写监听器接口声明监听事件处理办法 在web.xml文件将监听器接口实现类注册到Http服务器 ServletContextListener接口： 通过这个接口合法的检测全局作用域对象被初始化时刻以及被销毁时刻 监听时间处理方法： 1234//在全局作用域对象被Http服务器初始化时被调用public void contextInitlized();//在全局作用域对象被Http服务器销毁时被调用public void contextDestroy(); ServletContextAttributeListener接口： 通过这个接口合法的检测全局作用域对象共享数据变化时刻 监听事件处理方法： 123456//在全局作用域对象添加共享数据public void contextAdd();//在全局作用域对象更新共享数据public void contextReplaced();//在全局作用域对象删除共享数据public void contextRemove(); 过滤器接口——Filter接口： 介绍 来自于Servlet规范下接口，存在于Tomcat提供servlet-api.jar中。 Filter接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类 Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截 具体作用： 拦截Http服务器，帮助Http服务器检测当前请求合法性 拦截Http服务器，对当前请求进行增强操作 Filter接口实现类开发步骤：三步 创建一个Java类实现Filter接口 重写Filter接口中doFilter方法 web.xml将过滤器接口实现类注册到Http服务器 代码实现： 12345678910111213141516/*** http://localhost:8080/myWeb/mn.jpg?age=80*/public class OneFilter implements Filter &#123; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain) throws IOException, ServletException &#123; String age = req.getParameter(&quot;age&quot;); if(Integer.valueOf(age) &lt; 70) &#123; filterChain.doFilter(req, res); &#125; else &#123; res.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = res.getWriter(); out.print(&quot;&lt;center&gt;&lt;font style=&#x27;color:red;font-size:40px&#x27;&gt;爪巴!&lt;/font&gt;&lt;center&gt;&quot;); &#125; &#125;&#125; 12345678910111213141516&lt;!--web.xml中--&gt;&lt;filter&gt; &lt;filter-name&gt;oneFilter&lt;/filter-name&gt; &lt;filter-class&gt;OneFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;!--拦截地址的格式--&gt;&lt;!-- 调用具体文件，&lt;url-pattern&gt;/myweb/one&lt;/url-pattern&gt; 在调用某一个文件夹下所有的资源文件，&lt;url-pattern&gt;/myweb/*&lt;/url-pattern&gt; 在调用任意文件夹下某种类型文件，&lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; 在调用任意文件时，&lt;url-pattern&gt;/*&lt;/url-pattern&gt; --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;oneFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--表示访问所有资源文件都要启用过滤器--&gt;&lt;/filter-mapping&gt; JSP规范介绍 来自于JAVAEE规范中的一种 JSP规范制定了如何开发JSP文件代替响应对象将处理结果写入到响应体的开发流程 JSP规范制定了Http服务器应该如何调用管理JSP文件 响应对象存在弊端 适合将数据量较少的处理结果写入到响应体中 如果处理结果数量太多，使用响应对象增加开发难度 JSP优势 JSP文件在互联网通信过程，是响应对象替代品 降低将处理结果写入到响应体的开发工作量降低处理结果维护难度 在JSP文件开发中，可以直接将处理结果写入到JSP文件不需要手写out.print命令，在Http服务器调用JSP文件时，根据JSP规范要求自动将JSP文件书写的所有内容通过输出流写入到响应体 JSP文件运行原理HTTP服务器调用JSP文件步骤 HTTP服务器将JSP文件内容编辑为一个Servlet接口实现类 HTTP服务器将Servlet接口实现类编译为一个class文件 HTTP服务器负责创建这个class的实例对象，这个实例对象就是Servlet实例对象 Http服务器通过Servlet实例对象调用jsp_service方法，将JSP文件内容写入到响应体 Servlet与JSP 分工： Servlet：负责处理业务并得到处理结果 JSP：不负责业务处理，主要任务将Servlet中处理结果写入到响应体中 调用关系： Servlet工作完毕后，一般通过请求转发方式，向Tomcat中申请调用JSP 如何实现数据共享： Servlet将处理结果添加到请求作用域对象 JSP文件在运行时从请求作用域对象得到处理结果 JSP-EL工具包 介绍： 由Java技术开发的一个jar包 作用是降低JSP文件开发时Java命令开发强度 Tomcat服务器本身自带了EL工具包 EL表达式 命令格式： 1$&#123;作用域对象别名.共享数据&#125; 命令作用： EL表达式是EL工具包提供的一种特殊命令格式表达式命令格式 EL表达式在JSP文件上使用 负责在JSP文件上从作用域对象读取指定的共享数据并把它输出到响应体中 作用域对象别名 JSP文件可以使用的作用域对象 ServletContext application：全局作用域对象 HttpSession session：会话作用域对象 HttpServletRequest request：请求作用域对象 PageContext pageContext：当前页作用域对象 [^1]: 是JSP文件里面独有的作用域对象。servlet中不存在;在当前页作用域对象存放的共享数据仅能在当前jsp文件中使用，不能共享给其他Servlet或者其他jsp文件;真实开发过程中，主要用于JSTL标签与JSP文件之间数据共享; EL表达式提供的作用域对象别名 JSP EL表达式 application ${applicationScope.共享数据名} session ${sessionScope.共享数据名} request ${requestScope.共享数据名} pageContext ${pageScope.共享数据名} EL表达式将引用对象属性写入到响应体中 命令格式：${作用域对象别名.共享数据名.属性名} 命令作用：从作用域对象读取指定共享数据关联的引用对象的属性值，并自动将属性的结果写入响应体中 属性名：一定要去引用类型属性名完全一致（包括大小写） EL表达式没有提供遍历集合的方法，因此无法从作用域对象读取集合内容输出到响应体中。后续可以通过JSTL来补充 EL表达式简化版 命令格式：${共享数据名} 命令作用：EL表达式允许开发人员开发时省略作用域对象别名 工作原理：EL简化版由于没有指定作用域对象，所有在执行时采用猜算法 首先到pageContext定位共享数据，如果有就直接读取输出并结束执行 如果在pageContext没有定位成功，则到request定位共享数据，如果有就直接读取输出并结束执行 如果在request没有定位成功，则到session定位共享数据，如果有就直接读取输出并结束执行 如果在session没有定位成功，则到application定位共享数据，如果有就直接读取输出并结束执行 如果在application没有定位成功，则返回null 存在隐患： 容易降低程序执行速度 容易造成数据定位错误 简化版应用场景： 设计目的：简化从pageContext读取共享数据并输出的难度 EL表达式简化版尽管存在很多隐患，但是在实际开发过程中，开发人员为了节省时间，一般都使用简化版而拒绝标准版。 EL表达式——支持运算表达式 前提：在JSP文件有时需要将读取共享数据进行运算之后，将运算结果写入到响应体中 运算表达式： 数学运算：+，-，*，/ 关系运算：&gt;,&lt;,== 逻辑运算：&amp;&amp;，||，！ EL表达式提供内置对象 命令格式：${param.请求参数名} 命令作用：从通过请求对象读取当前请求包中请求对象参数内容，并将请求参数内容写入到响应体中 代替命令： 12345678910111213&lt;!--index.jsp--&gt;&lt;!--发送请求:Http://localhost:8080/myWeb/index.jsp?userName=mike&amp;password=123--&gt;&lt;% String userName = request.getParameter(&quot;userName&quot;); String password = request.getParameter(&quot;password&quot;);%&gt;&lt;%=userName%&gt;&lt;%=password%&gt;&lt;!--使用EL表达式--&gt;$&#123;param.userName&#125;$&#123;param.password&#125; 命令格式：${paramValues.请求参数名[下标]} 命令作用：如果浏览器发送的请求参数是一个请求参数关联多个值，此时可以通过paramValues读取请求参数下指定位置的值并写入响应体中 替代命令： 1234567891011121314&lt;!--index.jsp--&gt;&lt;!--发送请求:Http://localhost:8080/myWeb/index.jsp?pageNo=1&amp;pageNo=2&amp;pageNo=3--&gt;&lt;% String array[] = request.getParameterValues(&quot;pageNo&quot;);%&gt;&lt;%=array[0]%&gt;&lt;%=array[1]%&gt;&lt;%=array[2]%&gt;&lt;!--使用EL表达式--&gt;$&#123;paramValues.pageNo[0]&#125;$&#123;paramValues.pageNo[1]&#125;$&#123;paramValues.pageNo[2]&#125; EL表达式常见异常 javax.el.PropertyNotFoundException：没有找到属性。 常常是在EL表达式中写错了属性名 JavaScript介绍 JavaScript是一种专门在浏览器编译并执行的编程语言 JavaScript处理用户与浏览器之间请求问题 JavaScript采用弱类型编程语言风格对面向对象思想来进行实现的编程语言 弱类型编程语言风格vs强类型编程语言风格强类型编程语言风格 认为对象行为应该受到其修饰类型严格约束。 Java采用强类型编程语言风格对面向对象思想来实现的编程语言 1234567891011class student &#123; public String sname; public void sayHello() &#123; System.out.print(&quot;hello world&quot;); &#125;&#125;Student stu = new Student();stu.sname = &quot;mike&quot;; //合法stu.sayHello(); //合法stu.sid = 10; //在java认为是语法错误，修饰stu对象的Student类型没有提供这个属性 弱类型编程语言风格 认为对象行为不应该受到其修饰类型约束。可以根据实际需要来决定对象可以调用属性和方法 JavaScript采用弱类型编程语言风格对面向对象思想来进行实现的编程语言 1234var stu = new Object();stu.car = &quot;劳斯莱斯&quot;; //合法stu.play = function() &#123; return &quot;打游戏&quot;&#125; //合法stu.play(); JavaScript入门语法JavaScript中变量声明方式 命令格式： 123var a;var b = 1;var c,d=2; 注意：在JavaScript变量/对象，在声明不允许指定修饰类型，只能通过var来修饰 JavaScript中标识符命名规则 标识符只能由四种符号组成：英语字母，数字，下划线，美元符号$ 标识符首字母不能以数字开头 标识符不能采用JavaScript中的关键字，比如var JavaScript数据类型 基本数据类型： 数字类型（number）：JS中将整数与小数合称number类型 字符串类型（string）：JS中字符与字符串合称为string类型；既可以使用**’’也可以使用“”** 布尔类型（boolean）：JS中boolean类型的值只有true和false 高级引用数据类型： object类型：JS中所有通过构造函数生成的对象都是object类型 function类型：JS所有函数都是function类型 JavaScript中特殊值 undefined：JS中所有变量在没有赋值时，其默认值都是undefined由于Js根据变量的赋值来判断变量类型，此时由于变量没有赋值因此JS无法判断当前遍历数据类型，此时返回也是undefined，因此初学者认为undefined也是一种数据类型这种理解是错误的。 null：JS中当一个对象赋值为null时，表示对象引用了一个空内存，这个空内存既不能存数据也不能读数据；此时这个对象数据类型，在JS中仍被认为是object类型。 NaN：JS中当一个变量赋值为NaN，表示变量接收了一个非法数字（abc123）此时这个变量数据类型，在JS中仍被认为number类型 infinity：JS中当一个变量赋值为infinity，表示变量接收到一个无穷大数字，此时JS仍认为是number类型 JavaScript控制语句 和Java完全一致、 JavaScript函数声明方式 命令格式： 123456function 函数名(形参1，形参2)&#123; ... ... return //返回运行结果&#125; 注意： JS中，所有函数在声明时，都需要使用function进行修饰 JS中，所有函数在声明时，禁止指定函数返回数据类型 JS中，所有函数在声明时，形参既不能使用var来修饰也不能用数据类型修饰 JS中，所有函数在声明时，如果有返回值，此时应该通过return返回 JavaScript函数调用方式 浏览器并不会自动调用JS函数 可以通过命令行的方式来调用JS函数 通过绑定在HTML标签上的监听事件通知浏览器调用指定函数进行处理 JavaScript应用篇JavaScript作用​ 帮助浏览器对用户提出请求进行处理 DOM对象 DOM = Document Object Model，文档模型对象 JS不能直接操作HTML标签，只能通过HTML标签关联的DOM对象对HTML标签下达指令 DOM对象生命周期 浏览器在接收到HTML文件之后，将HTML文件标签加载到浏览器缓存中，每当加载一个HTML标签的时候，自动为这个标签生成生成一个实例对象，这个实例对象就是DOM对象 在浏览器关闭之前或者浏览器请求其他资源文件之前，本次生成的DOM对象一直存活在浏览器缓存中 在浏览器关闭时，浏览器缓存中的DOM对象将被销毁 在浏览器请求到新资源文件后，浏览器缓存中原有的DOM对象将被覆盖 document对象 document对象被称为文档对象 document对象用于在浏览器内存中根据定位条件定位DOM对象 document对象生命周期 在浏览器将网页中所有标签加载完毕后，在内存中将使用树形结构储存这些DOM对象。在树形结构生成完毕后由浏览器生成一个document对象管理这颗树（DOM树） 一个浏览器运行期间，只会生成一个document对象 在浏览器关闭时，会将document对象销毁 通过document对象定位DOM对象 根据HTML标签的id属性值定位DOM对象 1var domObj = document.getElementById(&quot;id属性&quot;); 根据HTML标签的name属性值定位DOM对象 1var domArray = document.getElementsByName(&quot;name属性&quot;); 根据HTML标签类型定位DOM对象 1var domArray = document.getElementsByTagName(&quot;标签类型&quot;); DOM对象控制标签属性 DOM对象对标签value属性进行取值与赋值操作 12345//取值操作 var domObj = document.getElementById(&quot;one&quot;); var num = domObj.value;//赋值操作 domObj.value = &quot;abc&quot;; DOM对象对标签样式属性进行取值与赋值操作 12345 var domObj = document.getElementById(&quot;one&quot;);//取值操作 var color = domObj.style.背景颜色属性//赋值操作 domObj.style.背景颜色属性 = 值 DOM对象对标签状态属性进行取值与赋值操作 状态属性：状态属性都是boolean类型 disabled：标签是否可用 checked：标签是否被选中 12345 var domObj = document.getElementById(&quot;one&quot;);//取值操作 var num = domObj.checked;//赋值操作 domObj.checked = true; DOM对象对标签文字显示内容进行取值与赋值操作 文字显示内容：只存在于双目标签之间 12345 var domObj = document.getElementById(&quot;one&quot;);//取值操作 var num1 = domObj.innerText;//赋值操作 domObj.innerText = 值; innerText与innerHTML区别： innerText与innnerHTML都可以对标签文字显示内容属性进行赋值与取值 innerText只能接收字符串 innerHTML既可以接收字符串又可以接收HTML标签 JavaScript监听事件 监听事件： 监听用户在何时以何种方式对当前标签进行操作。当监听到相关行为时，通知浏览器调用对应JavaScript函数对当前用户请求进行处理 监听事件分类： 监听用户何时使用鼠标操作当前标签 onclick：监听用户何时使用鼠标单击当前标签 onmouseover：监听用户何时将鼠标悬停在当前标签上方 onmouseout：监听用户何时将鼠标从当前标签上方离开 onfocus：监听用户何时通过鼠标让当前标签获得光标 onblur：监听用户何时通过鼠标让当前标签丢失光标 监听用户何时使用键盘操作当前标签 onkeydown：监听用户何时在当前标签上按下键盘 onkeyup：监听用户何时在当前标签上抬起键盘 onload监听事件 作用：监听浏览器何时将网页中HTML标签加载完毕 意义：浏览器每加载一个HTML标签时，自动在内存中生成一个DOM对象。在浏览器将网页所有标签加载完毕时，意味当前网页中所有标签都生成对应DOM对象。onload此时就可以触发调用函数对浏览器中标签进行处理，此时不会出现未找到DOM对象。 基于DOM对象实现监听事件与HTML标签之间的绑定 前提： 实际开发过程中，同一个监听事件往往与多个HTML标签进行绑定，这样增加开发难度，在未来维护过程中增加难度 命令形式 12var domObj = document.getElementByTagName(&quot;&quot;);domObj.监听事件名 = 处理函数名; //此处处理函数名后面不能写() JavaScript高级篇arguments属性 JS中每个函数都包含一个arguments属性 arguments属性是一个数组 在函数调用时，将实参传入到函数的arguments中，再由arguments将数据传递给形参 arguments属性存在，可以将JS中函数在调用时传递实参与形参进行格式，增加函数调用的灵活性 arguments属性只能在函数体内使用，不能在函数体外使用 function类型对象 介绍： function是JS中一个高级数据类型 一个function类型对象用于管理一个具体函数 JS中function类型相当于Java中Method类型 function类型对象生命周期 标准声明方式 123function 函数对象名(参数1,参数2) &#123; 命令...&#125; 匿名声明方式（命令行） 1var 函数对象名 = function (参数1,参数2) &#123;命令...&#125; function类型对象的创建时机 浏览器在加载时，共加载两次 第一次加载，将标签所有以标准形式声明函数对象进行创建 第二次加载，将标签所有命令行按照自上而下顺序来执行 全局变量与局部变量 局部变量： 定义：在函数执行体内，通过var修饰符声明的变量 特征：局部变量只能在当前函数执行体使用，不能再函数执行体外使用 全局变量： 定义： 全局变量可以在当前HTML文件中所有的函数使用 全局变量被声明时，自动分配给window对象作为其属性 声明全局变量： 第一种方法：直接在script标签下，通过var声明的变量，就是全局变量 第二种方式：在函数执行体内，没有通过var修饰的变量也是全局变量 object类型对象特征 定义：在JS认为所有通过构造函数生成的对象其数据类型都是object类型 特征：object类型对象在创建完毕后们可以根据实际情况，任意添加属性和方法，也可以一处属性和方法 属性维护： 第一种维护方案： 1234//添加属性 object对象.新属性名 = 值;//添加函数 object对象.新函数对象名 = function()&#123;&#125;; 第二种维护方案： 1234//添加属性 object对象[&quot;新属性名&quot;] = 值;//添加函数 object对象[&quot;新函数对象名&quot;] = function()&#123;&#125;; 移除对象属性和方法： 1234//移除属性 del object对象.属性名;//移除函数 del object对象.函数对象名; 自定义构造函数 命令： 12345function 函数对象名() &#123;&#125;//调用var object类型对象 = new 函数对象名(); 普通函数与构造函数区分： 函数没有调用之前，无法区分函数身份，只能根据函数调用形式区分 判断普通函数：var num = 函数对象名 (); 判断构造函数：var num = new 函数对象名 (); 返回值： 普通函数运行后需要通过return将执行结果返回； 构造函数运行后直接返回一个object类型对象，此时函数return相当于无效的 JavaScript中this指向 JS中this指向与Java中this指向完全一致 在构造函数，this指向当前构造函数生成object类型对象 在普通函数，this指向调用当前函数的实例对象 JSON 前提：JS中得到object类型对象方式 方式1：由构造函数生成的对象都是object类型对象 方式2：由JSON数据描述格式生成对象都是object类型对象 JSON数据描述格式： JS中获得object类型对象简化版 标准命令格式： 1var obj = &#123;&quot;属性名1&quot;:值,&quot;属性名2&quot;:值...&#125; 开发人员习惯于将由JSON生成object类型对象称为JSON对象 JSON数组： 专门存放JSON对象的数组被称为JSON数组 MVC开发规则介绍 MVC开发规则制定了互联网通信开发过程中必须出现的角色有哪些 MVC开发规则制定了互联网通信开发过程中必须出现的角色担负职责 MVC开发规则制定了互联网通信开发过程中必须出现的角色的出现顺序 角色 DAO对象： DAO对象提供某站表文件的操作细节，降低对表文件操作难度； 避免反复开发表文件操作代码提高代码复用性 Service对象： 服务对象，提供业务的具体解决方案； service对象一个方法指定一个业务的解决方案 避免业务开发重复性开发行为，提供复用性 网站每一个业务都有一个独立标准解决方案 业务 概念：浏览器向HTTP服务器发送请求就是一次业务 业务特征： 真实业务场景中，一个业务往往包含多个分支任务。因此解决业务开发工作量往往比较巨大 真实业务场景中，只有所有分支任务都能顺利成功解决，才可以认为当前业务处理成功 解决业务开发困扰： 一个业务可能在网站的多个地方重复出现，如果不去封装，增加开发朗读，进行业务解决代码重复性开发 不同程序员面对同一个业务时，给出的解决方案往往有偏差，导致最终解决数据会有偏差 互联网通信开发过程中必须出现的角色有哪些一次互联网开发过程，必须出现角色有三个： C，controller object：控制层对象（servlet对象） M，model object：业务模型对象（service对象） V，view object：视图层对象（jsp or HttpServletResponse） 互联网通信开发过程中必须出现的角色担负职责 C（servlet对象）： 可以调用请求对象读取请求包参数信息 必须调用Service对象处理业务 必须调用视图层对象将结果写入到响应体中 M（service对象）： 处理业务中所有分支任务 根据分支任务执行情况判断业务是否处理成功 必须通过return将处理结果返回给控制层对象 V（jsp or HttpServletResponse）： 禁止参与业务处理 唯一任务将处理结果写入到响应体中 互联网通信开发过程中必须出现的角色的出现顺序 请求调用顺序：浏览器——》Servlet——》Service——》DAO 响应顺序：DAO——》Service——》Servlet——》view——》响应体——》浏览器","categories":[],"tags":[]},{"title":"","slug":"DO NOT ADD FILES HERE","date":"2022-01-02T09:58:01.223Z","updated":"2021-08-30T15:51:22.000Z","comments":true,"path":"2022/01/02/DO NOT ADD FILES HERE/","link":"","permalink":"http://example.com/2022/01/02/DO%20NOT%20ADD%20FILES%20HERE/","excerpt":"","text":"This folder will be replaced / removed during update / uninstall. Do not write your files here.","categories":[],"tags":[]},{"title":"","slug":"DataBase","date":"2022-01-02T09:58:01.220Z","updated":"2021-12-26T13:23:10.868Z","comments":true,"path":"2022/01/02/DataBase/","link":"","permalink":"http://example.com/2022/01/02/DataBase/","excerpt":"","text":"大学数据库考试纲要1 第一章1.1 数据管理发展阶段 人工管理阶段 特点： 不保存数据 应用程序管理数据 数据不共享，冗余度大 程序与数据不具有独立性 文件系统管理阶段 优点： 数据可以长期保存 文件系统管理数据 程序与数据之间存在一定的独立性 缺点： 数据共享性差，冗余度大 数据独立性差。 数据库系统管理阶段 统一管理数据的专门的软件系统，即数据库管理系统。 NoSQL非结构化数据库 四大分类： 键值存储数据库 列存储数据库 文档型数据库 图形数据库 常见NoSQL数据库： MongoDB：基于分布式文件存储的数据库 HBase：一个分布式的、面向列的开源数据库 Redis：是一个键值存储系统 1.2 数据库相关概念 数据和信息 数据是信息的载体，而信息是数据的内涵。统一信息可以有不同的数据表示形式，而同一数据也可能有不同的解释。 数据库 存放数据的仓库，是长期存储在计算机内有组织的、可共享的大量数据集合。其中的数据按照一定的数据模型组织、描述和存储。 具有以下三个特点： 永久存储 有组织 可共享 数据库系统 是指引入数据库后的系统，包括数据库、数据库管理系统、应用系统和数据库管理员四部分组成。 数据库管理系统（DBMS） DBMS是位于用户和操作系统之间的一种数据管理软件，用于管理、控制和维护数据库，方便用户使用且提供对数据的保护。 2 第二章2.1 数据模型数据库需要将现实中的事物抽象成能够存储进数据库的数据，即数字化，数据模型就是对现实世界的模拟和抽象，用来描述数据是如何组成存储和操作的。 将实体数字化需要经过三个阶段：现实世界、信息世界和机器世界。 数据模型应当满足以下三种条件： 能比较真实地模拟现实世界 数据模型容易被人所理解 数据模型要能够很方便的再计算机上实现 根据数据模型应用的目的不同，分为现实世界到信息世界的概念层数据模型和信息世界到机器世界的组织层数据模型。 数据结构的组成元素包括： 数据结构 数据操作 数据的完整约束条件 根据数据模型的不同应用层次分类： 概念模型 逻辑模型 物理模型 2.2 概念模型用于对信息世界的组织和建模，是现实世界到机器世界的一个中间过程，是用户和数据库设计人员进行交流的语言。因此应当具有较强的语义性和简单性。 基本概念： 实体：现实世界相同事物或者概念的集合。 属性：实体所具有的某一特性。 码：唯一标识实体的属性集称为码。 实体型：用实体名和其属性集来抽象刻画所有同类实体，称为实体型。 实体集：统一类型实体的集合。 联系：实体内部和实体之间的联系。 联系： 两个实体之间的联系： 一对一联系（1 : 1）：对于实体集A中的每一个实体，在实体集B中至多有一个与之联系，反之亦然。 一对多联系（1 : n）：对于实体集A中的每一个实体，在实体集B中存在n个实体与之联系；对于实体集B中的每一个实体，在实体集A中仅有一个与之联系。 多对多联系（m : n）：对于实体集A中的每一个实体，在实体集B中存在n个实体与之联系；对于实体集B中的每一个实体，在实体集A中也有m个与之联系。 两个以上实体之间的联系：同样有一对一（1 : 1），一对多（1 : n），多对多（m : n : p）的联系 单个实体之间的联系：同样有一对一（1 : 1），一对多（1 : n），多对多（m : n : p）的联系 ER方法（实体-联系方法）： 用来描述现实世界信息结构的常用方法，通常使用ER图来描述，描述结果也被称为ER模型。 ER图由实体、属性和联系组成： 实体：用矩形表示。 属性：用椭圆表示，主码用下划线标明，用无向线段将其与实体连接。 联系：用菱形表示，用无向线段与有关实体连接。 2.3 逻辑模型必须要把概念模型转换为逻辑数据模型才能在DBMS中实现，因此逻辑模型既面向用户又面向系统。 逻辑数据模型就是一种组织数据的数据结构，是具体的DBMS支持的数据模型。 常见的逻辑数据模型： 层次模型：优点是实现简单、结构清晰、数据呈现完整；缺点是不能表示两种以上实体的联系和多对多联系、插入删除复杂、查询孩子节点必须经过双亲节点。 网状模型：优点是更直观的表现现实世界的复杂关系、具有良好的性能和存储效率；缺点是结构复杂、数据独立性差。 关系模型：就是我们常说的给关系表（employee表、student表……） 优点在于与其他模型相比，关系模型具有较强数据理论根据、数据结构简单清晰、关系模型的存取路径对用户不可见，方便程序员工作，也确保了更高的数据独立性和安全性； 缺点在于由于存取路径不可见，导致对数据的查询效率低需要优化，增加了开发DBMS的负担、关系必须是规范化的（即属性是不可再分的数据项，不允许表中有表）。 2.4 三层结构体系结构和数据独立性三层结构体系基于不同级别用户对数据库的认知不同，分为三层：外模式、模式（又称概念模式）、内模式。三级模式有助于提高数据库的逻辑独立性和物理独立性。 三级模式结构： 外模式：也称子模式或者用户模式，是用户或应用程序员能看到的一部分数据的逻辑结构和特征描述。外模式一般是模式的子集，可以有多个外模式。 模式：是介于内模式和外模式之间的模式，包含所有数据的逻辑结构和特征描述，因此只有一个概念模式。外模式都是模式的一部分体现。 内模式：也称存储模式，是所有数据的物理结构和存储结构的描述，即数据在数据库中是以什么方式存储的。只有一个内模式。 二级映像： 为了实现三级模式的联系和转换，DBMS在三级模式之间增加了二级映像。 外模式/模式映像：定义了外模式和模式的映射关系，当模式改变时，可以通过管理员手动调整映像的方式，让外模式也不会因此随之改变，确保了数据的逻辑独立性。由于存在多个外模式，所以也要存在多个外模式/模式映像。 模式/内模式映像：定义了数据的逻辑结构和存储结构的映射关系，当数据库存储结构改变时，可以通过管理员手动调整映像的方式，让模式也不会因此随之改变，确保了数据的物理独立性。由于模式和内模式都只有一个，所以模式/内模式映像也只有一个。 3 第三章关系是个体之间的关系，联系是实体之间的一对一、一对多、多对多联系。 在数据库领域，关系是一种特殊的表。 3.1 关系模型对关系的描述一般称为关系模式，形如：关系名（属性名1，属性名2……） 关系模型基础概念： 元组：关系中的每一行数据称为一个元组或者一条记录。 属性：关系种的每一列称为一个属性，列名就是属性名。 域：属性的取值范围就是域。 码：码也被称为键，指取值具有唯一性的属性，可以唯一确定一条记录的属性，他可以是一个属性也可以由多个属性组成。 主码：一个关系中的所有码构成候选码，为了方便管理，选择一个候选码作为主码，主码取值具有唯一性且不可为空。 外码：关系模式中某一个属性不是该关系模式的主码但是是另外一个关系模式的主码，就称其为外码。外码必须和参照主码具有相同的域，取值只能引用参照主码的值或者取null值。 3.2 关系的完整性约束完整性约束是为了保证数据的正确和相容性，对关系模型提出的某些约束条件或者规则。 完整性约束分类： 域完整性约束：指属性的取值域的范围约束，包括数据类型、格式、取值范围、是否可为空值等。 实体完整性约束：指所有的关系表都必须具有主码，且每个主码取唯一值和不能为空。 参照完整性约束：指所有外码的取值必须来自于参照主码，或者取空值，不能取不存在的值。 用户定义完整性约束：指针对某一具体关系数据库的约束条件，一般来说就是用户自定义的约束。 3.3 关系代数关系代数是对表中记录的操作，其中，选择、投影、并、差、笛卡尔积是五种基本查询操作。 关系代数运算符： 集合运算符：并（⋃）、交（⋂）、差（-）、笛卡尔积（×）。 关系运算符：选择（）、投影（Π）、连接（⋈）、除（÷）。 算术比较符：大于（＞）、大于等于（≥）、小于（＜）、小于等于（≤）、等于（=）、不等于（≠）。 逻辑运算符：与（⋀）、或（⋁）、非（）。 其他运算符：更名（ρ）、赋值（⬅）。 集合运算： 并相容性：集合R和S要进行并差交运算，集合R和S必须拥有相同的属性个数。 并：R和S种的所有元组的集合，相同的元组会被消除。 差：集合R种不属于S的元组的集合。 交：集合R和S种共有的元组的集合。由并和差两种操作组合衍生而来。 笛卡尔积：集合R种的元组和S中的元组的所有组合的集合。 关系运算： 选择：筛选出集合R中所有符合选择条件的元组。 投影：筛选出集合R中的某些列（属性）而丢弃其他列。 连接：将集合R和S关联起来，且仅保留符合连接条件的元组。是由笛卡尔积和选择两种操作组合衍生而来。 除：集合R中同时包含集合S中相同属性的元组的集合。 其他运算： 赋值运算：如果关系表达式的结果没有能够引用的名字，就无法运用于后面的运算，用赋值号给运算结果指定一个关系名。 更名运算：同样输给运算结果取名，还可以给运算结果中的属性名改名。 4 第四章略 5 第五章5.1 函数依赖函数依赖属于数据依赖的一种，当集合R中的两个元组在任意时刻，属性A相同时属性B也相同，则称A函数决定B，或称B函数依赖A。 函数依赖的分类： 完全函数依赖：属性Y函数依赖于属性X，但是属性Y不依赖X的任何真子集。 部分函数依赖：属性Y函数依赖于属性X，而且属性Y依赖于X的真子集。 传递函数依赖：属性Y函数依赖于属性X，属性X不依赖于Y，属性Z依赖于属性Y，则称属性Z（传递）依赖于X。 5.2 范式指规范的表现形式，在关系型数据库中指符合某一种级别的关系模式的集合。 满足第一范式被称为1NF，在此基础上，满足第二范式被称为2NF，以此类推。 六级范式： 第一范式：指一个关系模式种的所有属性都是不可再分的基本数据项。 第二范式：在满足第一范式的基础上，关系模式中的每个非主属性（主码，主键）都完全依赖于主属性。 第三范式：在满足第二范式的基础上，关系模式中的属性不依赖于其他非主属性。 BC范式：略 第四范式：略 第五范式：略 5.3 关系模式的规范化和反规范化规范化： 关系的规范化越低，越容易出现插入异常、删除异常等情况，因此需要对其进行规范化，将其转换为高级范式。规范化的过程是对关系进行分解的过程，目的在于减少冗余，消除更新、插入、删除的异常。需要注意的是并不是越高级的范式越好。 反规范化： 正如上述所说，并非越高级的范式越好，因此需要对关系进行反规范化，即对范式降级。反规范化就是对关系进行合成的过程，其目的在于通过引入部分合理的冗余，提高查询的效率降低查询的难度。 6 第六章6.1 数据库设计的阶段数据库设计就是在现有的硬件设施、DBMS、系统软件来满足用户的需求转换为有效的数据库模型的过程。 数据库设计的基本过程： 需求分析阶段：主要是收集数据和对其进行分析整理。 概念结构设计阶段：负责对用户需求进行分析，将其和数据转换为独立于DBMS的概念模型。 逻辑结构设计阶段：负责将概念模型转换为某个具体DBMS所支持的数据模型，并对其进行优化。 物理结构设计阶段：负责找到合适的物理模型存储逻辑模型。 数据库实施阶段：负责根据逻辑模型和物理模型建立数据库，将数据录入，并进行试运营。 数据库运行与维护阶段：数据库应用程序经过试运营后投入正式使用，在运行过程中不断对其进行优化和迭代。 6.2 概念结构设计阶段该阶段负责将用户需求转换为概念模型，该模型独立于DBMS仅专注于信息的组织结构和处理模式。 采用ER模型方法的概念结构设计通常可分为三步：抽象数据设计局部ER图、集成局部ER图得到全局概念结构、优化全局ER模型。 6.3 逻辑结构设计阶段该阶段负责将概念模型转换为适合DBMS的逻辑结构，分为三步：概念模型转换为关系数据模型、优化数据模型、针对具体应用设计用户外模式。 概念模型转换为关系数据模型就是将ER图表示的实体联系转换成关系模式，通常包含以下两个原则： 每个实体类型转换成一个关系模式，实体的属性就是关系模式的属性，实体的码就是关系模式的主码。 实体间联系根据不同情况有不同的处理，一般来讲需要注意，m:n的联系必须要转换成一个单独的关系模式。 7 第七章7.1 事务定义： 事务是用户定义的一个数据操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单元。 操作： 事务可以由用户开启，也可以让DBMS自动决定事务是否开启。事务相关的操作： BEGIN TRANSACTION：开启事务。 COMMIT：提交事务。 ROLLBACK：回滚事务。 特征（ACID特性）： 原子性（Atomicity）：指事务的操作要么全部做要么都不做，不可分割。 一致性（Consistency）：是指数据库必须从一个一致性转为另一个一致性，不允许部分改变。一致性和原子性紧密相关。 隔离性（Isolation）：指事务不能受到其他事务的干扰，事务之间必须是相互隔离互不干扰的。 持久性（Durability）：也称永久性，事务一旦提交，对数据库的修改就是永久性的。 7.2 并发控制让事务串行执行虽然可以有效保持数据库的一致性，但是效率颇低，于是为了提高数据库的并行度，避免数据库资源的闲置浪费，可以让多个事务同时执行，即并发执行。 而在这个过程中，可能存在多个事务同时对一段数据进行读取或改写，出现各种各样的错误，破坏数据库的一致性，因此保护数据库一致性的这个过程就是并发控制。 并发操作引起的问题： 丢失更新问题：两个事务同时读取并修改同一段数据，事务2的提交覆盖了事务1的提交，导致事务1的更新丢失。 读“脏”数据问题：事务1对一段数据进行修改后，事务2读取了该段数据，但是由于某种原因，事务1撤销了自己的修改操作，导致事务2之前读取到的数据与现在数据库中的数据不同，称之为读脏数据。读到脏数据的原因就是读取了未提交事务的数据（或称未提交数据）。 不可重复读问题：事务1读取一段数据后，事务2修改了该段数据，此时事务1再读取该段数据却得到了不同的数据，读取数据被称为检索，所有又称检索不一致。 并发控制的手段——封锁技术（或简称锁）： 封锁（Locking）：就是事务T在操作某一个数据对象之前，向DBMS发送一段请求对操作对象上锁，被上锁的数据对象不能被除事务T以外的事务修改，确保了数据库的一致性。 锁的分类： 排他锁（简称X锁）：又称写锁，事务T对数据对象上了X锁之后，只有事务T能够读取和更新该数据对象，其他事务就不能再对该对象上任何锁，也不能读取和更新该数据对象，直到事务T释放X锁。 共享锁（简称S锁）：又称读锁，事务T对数据对象上了S锁之后，事务T只能读取该数据对象而不能更新，其他事务只能对该数据对象上S锁而不能加X锁，直到事务T释放S锁。注意上了S锁之后，所有事务都只能读而不能修改。 封锁协议： 封锁协议规定了何时上锁，何时释放锁和封锁的时间等，不同等级的封锁协议在一定程度上保证了数据库的一致性避免并发操作引起问题。 一级封锁协议：在需要修改数据之前，必须对数据上X锁，直到事务完成（事务完成包括commit提交和roolback回滚）。一级协议保证了不会出现丢失更新的问题，但是如果只读数据就不用上锁，因此还是可能出现脏数据和不可重复读问题。 二级封锁协议：在一级封锁协议的基础上，事务在读取数据之前，必须对数据上S锁，直到数据读取完成就释放S锁。二级协议除了保证了不会出现丢失更新问题，还保证避免了读脏数据的问题。但是由于数据在读取完成后就释放S锁，这时其他事务就可以修改数据了，所以还是会存在不可重复读的问题。 三级封锁协议：在一级封锁协议的基础上，事务在读取数据之前，必须对数据上S锁，直到事务完成后才释放S锁。这样就可以保证在事务完成之前，无论读多少次数据都能得到相同的结果，因此避免了不可重复读的问题。 死锁：同操作系统的死锁，两个事务都在等待对方释放上锁的数据，导致两个事务都不能完成。 并发调度的可串行性：见下一节。 7.3 并发调度的可串行性串行调度： 即每个事务都顺序执行，这种情况下虽然串行的顺序不一定相同，但执行结果总是正确的； 并发调度： 区别于串行调度，时刻可以同时执行，这时并行的顺序就可能影响执行结果的正确性。 并发调度的可串行性： 指找到并行执行的某个顺序下的结果，与某一串行执行的结果相同，就可以说这个并行执行是正确的。 二段锁协议： 是DBMS确保并发调度可串行性的手段，其含义是：将事务分为两个阶段，第一阶段只允许申请封锁，第二阶段只允许释放封锁。 实现了二段锁协议的事务只是具备了可串行化的充分条件而不是必要条件，意思是可串行化的事务同样可以不遵守二段锁协议。 7.4 数据恢复数据库在运行中可能发生各种各样的故障： 事务内部故障：及时回滚事务，并且检查并修复事务内部错误即可。 系统故障：因为各种原因导致系统重启，使部分事务错误提交或未执行导致数据库内部数据错误，需要根据日志还大批量回滚和重做事务来修复。 介质故障：因为外界因素导致数据库严重损坏、数据丢失等问题，需要将数据库恢复到之前的备份。 计算机病毒：略 10 第十章10.1 安全控制模型数据库的安全控制包括四个过程，分别是：操作系统安全、SQL Server验证、数据库访问权限、数据库对象访问权限。其中只有最后三个过程由SQL Server负责。 三个过程： SQL Server验证：确定用户是否使数据库服务器的合法用户，即拥有登陆账号。 数据库访问权限：确定用户是否是某个数据库的合法用户。 数据库对象访问权限：确定用户是否有合适的操作权限。 10.2 身份验证模式SQL Server提供了两种身份验证模式： windows身份验证模式：即SQL Server通过验证当前用户是否是Windows系统的合法用户来确定是否是数据库服务器的合法用户 混合身份认证模式：即同时允许Windows合法用户和SQL Server单独授权的用户登录到数据库服务器上。 10.3 登录名、用户、角色管理登录名、用户、角色的区分： 登录名：数据库访问者需要登录到数据库服务器中，因此需要有一个登录号来通过安全控制的SQL Server验证的过程。 用户：是指对某个数据库具有访问和操作权限的访问者，这个用户身份需要被授予给登录名。 角色：特指具有一系列权限的身份，这个角色身份可以赋予给用户，此时这个用户就具有了该角色所有的权限。 登录名管理： 创建：CREATE LOGIN login_name WITH PASSWORD = &#39;...&#39; 删除：DROP LOGIN login_name 用户管理： 创建：CREATE USER user_name FOR LOGIN login_name 删除：DROP USER user_name 角色管理： 创建：CREATE ROLE role_name 在创建时赋予用户角色或覆盖其他角色：CREATE ROLE role_name AUTHORIZATION owner_name 将某用户添加到角色中：EXEC sp_addrolemember &#39;role_name&#39;, &#39;user_name&#39; 将某用户从角色中删除：EXEC sp_droprolemember &#39;role_name&#39;, &#39;user_name&#39; 删除：DROP ROLE role_name 10.4 权限管理权限分类： 对象权限：即增删改查. 语句权限：即CREATE. 隐含权限：DBMS默认创建的权限。 权限管理： 赋予权限：允许用户或角色具有某种操作权。 收回权限：不允许用户或角色具有某种操作权，或者收回之前赋予的权限。 拒绝权限：拒绝用户或角色因为继承而获得某种操作权。 T-SQL语句： 赋予： 对象权限：GRANT SELECT, DELETE, INSERT, UPDATE ON table_name TO owner_name 语句权限：GRANT CREATE TABLE, CREATE VIEW, CREATE DATABASE TO owner_name 收回： 对象权限：REVOKE SELECT, DELETE, INSERT, UPDATE ON table_name FROM owner_name 语句权限：REVOKE CREATE TABLE, CREATE VIEW, CREATE DATABASE FROM owner_name 拒绝： 对象权限：DENY SELECT, DELETE, INSERT, UPDATE ON table_name TO owner_name 语句权限：DENY CREATE TABLE, CREATE VIEW, CREATE DATABASE TO owner_name 11 第十一章11.1 备份备份的目的： 为了能够在发生某种故障（见7.4小节）时，及时将已损坏的数据库恢复正常。 备份的分类： 完整备份：将所有数据库信息都进行备份，备份下来的时一个完整的数据库。数据库的备份需要时间，在备份中用户同样可以进行操作，且备份会将备份过程中执行的操作记录下来。 差异备份：是对最近一次备份以来发生的数据变化进行备份，它的特点是速度快体积小，通过增加差异备份的次数，可以有效减少数据丢失的风险。 事务日志备份：仅对事务日志进行备份，事务日志中包含了从上一次备份以来所有已经完成的事务。事务日志备份由于只备份事务日志，所以速度更快、占据磁盘空间更小。 需要注意的是，差异备份和事务日志备份尽管都只备份一部分数据加快了备份速度，但是差异备份只保留最近一次修改，事务日志保留了从上一次备份以来的所有事务。 备份内容： 系统数据库：记录了重要的系统信息，必须完整备份。一旦进行修改，最好立刻备份。 用户数据库：记录了重要的用户数据，必须完整备份。可以进行周期性的备份。 事务日志：事务日志体积小，备份时间短，但是恢复需要的时间长。 建立备份：（其实不重要，强迫症迫使我写了） 完整备份： 追加式：BACKUP DATABASE database_name TO DISK=&#39;备份设备路径.bak&#39; 覆盖式：BACKUP DATABASE database_name TO DISK=&#39;备份设备路径.bak&#39; WITH INIT 差异备份： 追加式：BACKUP DATABASE database_name TO DISK=&#39;备份设备路径.bak&#39; WITH DIFFERENTIAL 覆盖式：BACKUP DATABASE database_name TO DISK=&#39;备份设备路径.bak&#39; WITH DIFFERENTIAL, INIT 日志备份： 截断式：BACKUP LOG database_name TO DISK=&#39;备份设备路径_log&#39; 不截断式：BACKUP LOG database_name TO DISK=&#39;备份设备路径_log&#39; WITH NO_TRUNCATE 11.2 备份策略策略一：完整备份 适合于数据量不大，或者不平凡修改的数据库。 策略二：完整备份+日志备份 适用于用户不允许丢失太多数据，但又不想经常完整备份的情况。 策略三：完整备份+差异备份+日志备份 适用于用户不允许丢失太多数据，但又不想经常完整备份的情况，而且恢复速度比较块的情况。 11.3 备份恢复恢复顺序（流程）： 恢复最近的完整数据库备份。 恢复完整备份之后的最近的差异数据库备份。 按事务日志的备份的先后顺序回资完整备份的所有日志备份。 12 第十二章我们可以在数据库里面完成做一些编程相关的事。 12.1 变量变量分类： 局部变量：用户自定义的变量，可以用来存储数值或者字符串，以@开头。 全局变量：不能又用户定义的变量，是DBMS自带的变量，以@@开头，一般存有某些特定的值。 变量声明和赋值： 声明：DECLARE @local_variable_name datatype 赋值：SET @local_variable_name = expression 或者 SELECT @local_variable_name = expression 运算符: 略 12.2 流程控制选择判断： IF...ELSE 和 CASE...ELSE 循环： WHILE...CONTINUE...BREAK 分段符： BEGIN...END 12.3 存储过程存储过程定义： 是为了实现某一功能的语句集合体，这些语句集合为一个完整单元并给他取一个名字。 优点： 存储编译结果，执行速度快、效率高。 可被多次调用。 存储过程存储在数据库中，可以方便的被用户调用。 存储过程可以接收传出数据，可以被嵌套使用。 开发者可以不必在客户端编写大量代码。 创建： 不带参数：123CREATE PROCEDURE nameAS(...) 带参数：123456CREATE PROCEDURE name@v1 datatype,@v2 datatype,@result datatype OUTPUTAS(...) 删除： DROP PROCEDURE name 执行： EXEC name &#39;v1&#39;, &#39;v2&#39;, @answer OUTPUT 12.4 触发器触发器定义： 触发器是在对表进行插入、更新或者删除操作时自动执行的存储过程，触发器时一种高级约束。 触发器类型： AFTER触发器：在执行INSERT、UPDATE、DELETE之后执行的触发器。 INSTEAD OF触发器：在执行指定操作之前触发，不执行指定操作而是执行INSTEAD OF触发器中定义的操作。 inserted和deleted表： 这两张表是在触发器触发时临时创建的两张表，只可读不可写，触发器执行完之后自动删除。 inserted表：临时保存了插入或者更新之后的记录行。 deleted表：临时保存了删除或者更新之前的记录行。 可以在触发器内查询这两张表来决定是否进行某种操作。 创建： 12345CREATE TRIGGER trigger_nameON table_nameFOR [DELEtE, INSERT, UPDATE]AS(...) 删除： DROP TRIGGER trigger_name 大概","categories":[],"tags":[]},{"title":"AJAX","slug":"AJAX","date":"2022-01-02T09:58:01.217Z","updated":"2022-01-02T09:59:54.028Z","comments":true,"path":"2022/01/02/AJAX/","link":"","permalink":"http://example.com/2022/01/02/AJAX/","excerpt":"","text":"AJAX全局刷新与局部刷新 全局刷新：整个浏览器都被新的数据覆盖，在网络中传输大量的数据，浏览器需要加载，渲染页面。 局部刷新：在浏览器的内部发起请求，获取数据，改变页面中的部分内容，其余的页面无需加载和渲染。网络中数据传输量少，用户体验更好 ajax是用来做局部刷新的，局部刷新使用的核心是异步对象（XMLHttpRequest），这个异步对象是存在于浏览器内存中的，使用javascript语法创建和使用XMLHTTPRequest对象。 AJAX是什么 AJAX：Asynohronous JavaScript And XML（异步的JavaScript和XML）。 Asynohronous：异步的意思 JavaScript：Javascript脚本 XML：是一种数据格式 ajax是一种局部刷新的新方法（2003），不是一种语言，ajax包含的技术主要有JavaScript，dom，xml，css等等，核心是JavaScript和XML JavaScript：负责创建异步对象，发送请求，更新页面的dom对象。ajax请求需要服务器端的数据。 XML：网络中的传输的数据格式。现在使用json替换了xml AJAX异步实现步骤 创建对象： 1var xmlHttp = new XMLHttpRequest(); 绑定事件（onreadystatechange事件）： onreadystatechange：当异步对象发起请求，获取了数据都会触发这个事件。这个事件需要指定一个函数，在函数中处理状态的变化。 12345678xmlHttp.onreadystatechange = function() &#123; //处理请求的状态变化 if(xmlHttp.readystate == 4 &amp;&amp; xmlHttp.status == 200) &#123; //可以处理数据，更新页面 var data = xmlHttp.responseText; document.getElementById(&quot;name&quot;).value = data; &#125;&#125; 初始异步请求对象： 123//xmlHttp.open(请求方式get/post，“服务端的访问地址”，同步/异步（默认是true异步）)xmlHttp.open(&quot;get&quot;,&quot;/myWeb/loginServlet?name=123&amp;pwd=123&quot;,true); 使用异步对象发送请求： 1xmlHttp.send() 获取服务端返回的数据，使用异步对象的属性responseText 1var data = xmlHttp.responseText 属性说明： onreadystatechange属性：当异步对象发起请求，获取了数据都会触发这个事件。这个事件需要指定一个函数或者直接定义函数，在函数中处理状态的变化。 readystate属性：存有XMLHttpRequest的状态，从0到4发生变化 0：请求未初始化，创建异步请求对象，var xmlHttp = new XMLHttpRequest(); 1：初始化异步请求对象，xmlHttp.open(请求方式，请求地址，true) 2：异步对象发送请求，xmlHttp.send() 3：异步对象接收应答数据从服务器返回数据，XMLHttpRequest内部处理。 4：异步请求对象已经将数据解析完毕，此时才可以读取数据。开发人员更新页面 status属性：表示网络请求的状况，需要status == 200时，表示网络请求是成功的 使用JSON替代XML作为返回数据格式 为什么使用JSON json格式容易理解 json格式数据在多种语言中，比较容易处理。使用java，JavaScript读写json格式的数据比较容易 json格式数据它占用的空间下，网络传输快，用户体验好 处理JSON的工具库 Gson(google) FastJson(Alibaba)：速度快，但不符合标准 Jackson：性能好，规范好 json-lib：性能差，依赖多 Jackson的使用 1234TestClass testClass = new TestClass();ObjectMapper om = new ObjectMapper();String json = om.writeValueAsString(testClass); 在js中将json格式的字符串转为json对象 123var data = xmlHttp.responseText//eval是执行括号中的代码，将json字符串转为json对象var jsonObj = eval(&quot;(&quot;+data+&quot;)&quot;); 同步和异步的区别 异步请求：不用等待数据处理完毕，就可以执行其他操作 同步请求：必须处理完成请求，从服务器端获取数据后，才能执行send之后的代码，任意时刻只能执行一个请求","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-02T07:52:25.016Z","updated":"2022-01-02T07:52:25.017Z","comments":true,"path":"2022/01/02/hello-world/","link":"","permalink":"http://example.com/2022/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}